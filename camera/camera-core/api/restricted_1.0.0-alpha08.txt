// Signature format: 3.0
package androidx.camera.core {

  public class AspectRatio {
    field public static final int RATIO_16_9 = 1; // 0x1
    field public static final int RATIO_4_3 = 0; // 0x0
  }

  @IntDef({androidx.camera.core.AspectRatio.RATIO_4_3, androidx.camera.core.AspectRatio.RATIO_16_9}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface AspectRatio.Ratio {
  }

  public interface Camera {
    method public androidx.camera.core.CameraControl getCameraControl();
    method public androidx.camera.core.CameraInfo getCameraInfo();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class CameraCaptureResults {
    method public static androidx.camera.core.impl.CameraCaptureResult? retrieveCameraCaptureResult(androidx.camera.core.ImageInfo);
  }

  public interface CameraControl {
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> cancelFocusAndMetering();
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enableTorch(boolean);
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setLinearZoom(@FloatRange(from=0.0f, to=1.0f) float);
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setZoomRatio(float);
    method public com.google.common.util.concurrent.ListenableFuture<androidx.camera.core.FocusMeteringResult!> startFocusAndMetering(androidx.camera.core.FocusMeteringAction);
  }

  public static final class CameraControl.OperationCanceledException extends java.lang.Exception {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public CameraControl.OperationCanceledException(String);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public CameraControl.OperationCanceledException(String, Throwable);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface CameraFactory {
    method public String? cameraIdForLensFacing(@androidx.camera.core.CameraSelector.LensFacing int) throws androidx.camera.core.CameraInfoUnavailableException;
    method public java.util.Set<java.lang.String!> getAvailableCameraIds() throws androidx.camera.core.CameraInfoUnavailableException;
    method public androidx.camera.core.impl.CameraInternal getCamera(String) throws androidx.camera.core.CameraInfoUnavailableException;
    method public androidx.camera.core.impl.LensFacingCameraIdFilter getLensFacingCameraIdFilter(@androidx.camera.core.CameraSelector.LensFacing int);
  }

  public static interface CameraFactory.Provider {
    method public androidx.camera.core.CameraFactory newInstance(android.content.Context);
  }

  public interface CameraInfo {
    method public androidx.lifecycle.LiveData<java.lang.Float!> getLinearZoom();
    method public androidx.lifecycle.LiveData<java.lang.Float!> getMaxZoomRatio();
    method public androidx.lifecycle.LiveData<java.lang.Float!> getMinZoomRatio();
    method public int getSensorRotationDegrees();
    method public int getSensorRotationDegrees(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method public androidx.lifecycle.LiveData<java.lang.Integer!> getTorchState();
    method public androidx.lifecycle.LiveData<java.lang.Float!> getZoomRatio();
    method public boolean hasFlashUnit();
  }

  public final class CameraInfoUnavailableException extends java.lang.Exception {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public CameraInfoUnavailableException(String!, Throwable!);
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public CameraInfoUnavailableException(String!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class CameraOrientationUtil {
    method public static int getRelativeImageRotation(int, int, boolean);
    method public static int surfaceRotationToDegrees(@androidx.camera.core.ImageOutputConfig.RotationValue int);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class CameraRepository {
    ctor public CameraRepository();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> deinit();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraInternal! getCamera(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void init(androidx.camera.core.CameraFactory!);
    method public void onGroupActive(androidx.camera.core.UseCaseGroup!);
    method public void onGroupInactive(androidx.camera.core.UseCaseGroup!);
  }

  public final class CameraSelector {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.LinkedHashSet<androidx.camera.core.impl.CameraIdFilter!> getCameraFilterSet();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer? getLensFacing();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public String select(java.util.Set<java.lang.String!>);
    field public static final androidx.camera.core.CameraSelector DEFAULT_BACK_CAMERA;
    field public static final androidx.camera.core.CameraSelector DEFAULT_FRONT_CAMERA;
    field public static final int LENS_FACING_BACK = 1; // 0x1
    field public static final int LENS_FACING_FRONT = 0; // 0x0
  }

  public static final class CameraSelector.Builder {
    ctor public CameraSelector.Builder();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraSelector.Builder appendFilter(androidx.camera.core.impl.CameraIdFilter);
    method public androidx.camera.core.CameraSelector build();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.CameraSelector.Builder fromSelector(androidx.camera.core.CameraSelector);
    method public androidx.camera.core.CameraSelector.Builder requireLensFacing(@androidx.camera.core.CameraSelector.LensFacing int);
  }

  @IntDef({androidx.camera.core.CameraSelector.LENS_FACING_FRONT, androidx.camera.core.CameraSelector.LENS_FACING_BACK}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface CameraSelector.LensFacing {
  }

  @MainThread @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class CameraX {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.Camera bindToLifecycle(androidx.lifecycle.LifecycleOwner, androidx.camera.core.CameraSelector, androidx.camera.core.UseCase!...);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static java.util.Collection<androidx.camera.core.UseCase!>? getActiveUseCases();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.CameraFactory getCameraFactory();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.impl.CameraInfoInternal getCameraInfo(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static String? getCameraWithCameraSelector(androidx.camera.core.CameraSelector);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static String? getCameraWithLensFacing(@androidx.camera.core.CameraSelector.LensFacing int) throws androidx.camera.core.CameraInfoUnavailableException;
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static android.content.Context getContext();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.CameraSelector.LensFacing public static int getDefaultLensFacing() throws androidx.camera.core.CameraInfoUnavailableException;
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static <C extends androidx.camera.core.UseCaseConfig<?>> C? getDefaultUseCaseConfig(Class<C!>!, Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static com.google.common.util.concurrent.ListenableFuture<androidx.camera.core.CameraX!> getOrCreateInstance(android.content.Context);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.impl.CameraDeviceSurfaceManager getSurfaceManager();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static boolean hasCamera(androidx.camera.core.CameraSelector) throws androidx.camera.core.CameraInfoUnavailableException;
    method public static com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> initialize(android.content.Context, androidx.camera.core.CameraXConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static boolean isBound(androidx.camera.core.UseCase);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static boolean isInitialized();
    method public static com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> shutdown();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static void unbind(androidx.camera.core.UseCase!...);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static void unbindAll();
  }

  public final class CameraXConfig implements androidx.camera.core.Config {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean containsOption(androidx.camera.core.Config.Option<?>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void findOptions(String, androidx.camera.core.Config.OptionMatcher);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.concurrent.Executor? getCameraExecutor(java.util.concurrent.Executor?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraFactory.Provider? getCameraFactoryProvider(androidx.camera.core.CameraFactory.Provider?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraDeviceSurfaceManager.Provider? getDeviceSurfaceManagerProvider(androidx.camera.core.impl.CameraDeviceSurfaceManager.Provider?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.CameraX!>? getTargetClass(Class<androidx.camera.core.CameraX!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.CameraX!> getTargetClass();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public String? getTargetName(String?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public String getTargetName();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCaseConfigFactory.Provider? getUseCaseConfigFactoryProvider(androidx.camera.core.UseCaseConfigFactory.Provider?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<androidx.camera.core.Config.Option<?>!> listOptions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>, ValueT?);
    field public static final androidx.camera.core.Config.Option<java.lang.Class<?>!>! OPTION_TARGET_CLASS;
    field public static final androidx.camera.core.Config.Option<java.lang.String!>! OPTION_TARGET_NAME;
  }

  public static final class CameraXConfig.Builder {
    ctor public CameraXConfig.Builder();
    method public androidx.camera.core.CameraXConfig build();
    method public static androidx.camera.core.CameraXConfig.Builder fromConfig(androidx.camera.core.CameraXConfig);
    method public androidx.camera.core.CameraXConfig.Builder setCameraExecutor(java.util.concurrent.Executor);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraXConfig.Builder setCameraFactoryProvider(androidx.camera.core.CameraFactory.Provider);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraXConfig.Builder setDeviceSurfaceManagerProvider(androidx.camera.core.impl.CameraDeviceSurfaceManager.Provider);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraXConfig.Builder setTargetClass(Class<androidx.camera.core.CameraX!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraXConfig.Builder setTargetName(String);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CameraXConfig.Builder setUseCaseConfigFactoryProvider(androidx.camera.core.UseCaseConfigFactory.Provider);
  }

  public static interface CameraXConfig.Provider {
    method public androidx.camera.core.CameraXConfig getCameraXConfig();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class CameraXThreads {
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final String TAG = "CameraX-";
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface CaptureBundle {
    method public java.util.List<androidx.camera.core.CaptureStage!>! getCaptureStages();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class CaptureConfig {
    method public static androidx.camera.core.CaptureConfig! defaultEmptyCaptureConfig();
    method public java.util.List<androidx.camera.core.impl.CameraCaptureCallback!>! getCameraCaptureCallbacks();
    method public androidx.camera.core.Config! getImplementationOptions();
    method public java.util.List<androidx.camera.core.DeferrableSurface!>! getSurfaces();
    method public Object! getTag();
    method public int getTemplateType();
    method public boolean isUseRepeatingSurface();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class CaptureConfig.Builder {
    ctor public CaptureConfig.Builder();
    method public void addAllCameraCaptureCallbacks(java.util.Collection<androidx.camera.core.impl.CameraCaptureCallback!>!);
    method public void addCameraCaptureCallback(androidx.camera.core.impl.CameraCaptureCallback!);
    method public void addImplementationOptions(androidx.camera.core.Config!);
    method public void addSurface(androidx.camera.core.DeferrableSurface!);
    method public androidx.camera.core.CaptureConfig! build();
    method public void clearSurfaces();
    method public static androidx.camera.core.CaptureConfig.Builder! createFrom(androidx.camera.core.UseCaseConfig<?>!);
    method public static androidx.camera.core.CaptureConfig.Builder! from(androidx.camera.core.CaptureConfig!);
    method public androidx.camera.core.Config! getImplementationOptions();
    method public java.util.Set<androidx.camera.core.DeferrableSurface!> getSurfaces();
    method public void removeSurface(androidx.camera.core.DeferrableSurface!);
    method public void setImplementationOptions(androidx.camera.core.Config!);
    method public void setTag(Object!);
    method public void setTemplateType(int);
    method public void setUseRepeatingSurface(boolean);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface CaptureConfig.OptionUnpacker {
    method public void unpack(androidx.camera.core.UseCaseConfig<?>!, androidx.camera.core.CaptureConfig.Builder!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface CaptureProcessor {
    method public void onOutputSurface(android.view.Surface!, int);
    method public void onResolutionUpdate(android.util.Size!);
    method public void process(androidx.camera.core.ImageProxyBundle!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface CaptureStage {
    method public androidx.camera.core.CaptureConfig! getCaptureConfig();
    method public int getId();
  }

  public static final class CaptureStage.DefaultCaptureStage implements androidx.camera.core.CaptureStage {
    method public androidx.camera.core.CaptureConfig! getCaptureConfig();
    method public int getId();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface Config {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean containsOption(androidx.camera.core.Config.Option<?>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void findOptions(String!, androidx.camera.core.Config.OptionMatcher!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<androidx.camera.core.Config.Option<?>!>! listOptions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT! retrieveOption(androidx.camera.core.Config.Option<ValueT!>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>!, ValueT?);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract static class Config.Option<T> {
    method public static <T> androidx.camera.core.Config.Option<T!>! create(String!, Class<?>!);
    method public static <T> androidx.camera.core.Config.Option<T!>! create(String!, Class<?>!, Object?);
    method public abstract String! getId();
    method public abstract Object? getToken();
    method public abstract Class<T!>! getValueClass();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface Config.OptionMatcher {
    method public boolean onOptionMatched(androidx.camera.core.Config.Option<?>!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface ConfigProvider<C extends androidx.camera.core.Config> {
    method public C! getConfig(Integer?);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract class DeferrableSurface {
    ctor public DeferrableSurface();
    method public final void close();
    method public final com.google.common.util.concurrent.ListenableFuture<android.view.Surface!> getSurface();
    method public void notifySurfaceAttached();
    method public void notifySurfaceDetached();
    method public void setOnSurfaceDetachedListener(java.util.concurrent.Executor, androidx.camera.core.DeferrableSurface.OnSurfaceDetachedListener);
    field protected static final String TAG = "DeferrableSurface";
  }

  public static interface DeferrableSurface.OnSurfaceDetachedListener {
    method public void onSurfaceDetached();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class DeferrableSurface.SurfaceClosedException extends java.lang.Exception {
    ctor public DeferrableSurface.SurfaceClosedException(String, Throwable, androidx.camera.core.DeferrableSurface);
    ctor public DeferrableSurface.SurfaceClosedException(String, androidx.camera.core.DeferrableSurface);
    method public androidx.camera.core.DeferrableSurface getDeferrableSurface();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class DeferrableSurfaces {
    method public static com.google.common.util.concurrent.ListenableFuture<java.util.List<android.view.Surface!>!> surfaceListWithTimeout(java.util.Collection<androidx.camera.core.DeferrableSurface!>, boolean, long, java.util.concurrent.Executor, java.util.concurrent.ScheduledExecutorService);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public abstract class DeviceProperties {
    ctor public DeviceProperties();
    method public static androidx.camera.core.DeviceProperties! create();
    method public static androidx.camera.core.DeviceProperties! create(String!, String!, int);
    method public abstract String! manufacturer();
    method public abstract String! model();
    method public abstract int sdkVersion();
  }

  public final class DisplayOrientedMeteringPointFactory extends androidx.camera.core.MeteringPointFactory {
    ctor public DisplayOrientedMeteringPointFactory(android.content.Context, androidx.camera.core.CameraSelector, float, float);
    ctor public DisplayOrientedMeteringPointFactory(android.view.Display, androidx.camera.core.CameraSelector, float, float);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected android.graphics.PointF convertPoint(float, float);
  }

  public interface ExtendableBuilder<T> {
    method public T build();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.MutableConfig getMutableConfig();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class ExtendableUseCaseConfigFactory implements androidx.camera.core.UseCaseConfigFactory {
    ctor public ExtendableUseCaseConfigFactory();
    method public <C extends androidx.camera.core.UseCaseConfig<?>> C? getConfig(Class<C!>, Integer?);
    method public <C extends androidx.camera.core.Config> void installDefaultProvider(Class<C!>, androidx.camera.core.ConfigProvider<C!>);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class FlashModeHelper {
    method public static String nameOf(@androidx.camera.core.ImageCapture.FlashMode int);
    method @androidx.camera.core.ImageCapture.FlashMode public static int valueOf(String?);
  }

  public final class FocusMeteringAction {
    method public long getAutoCancelDurationInMillis();
    method public java.util.List<androidx.camera.core.MeteringPoint!> getMeteringPointsAe();
    method public java.util.List<androidx.camera.core.MeteringPoint!> getMeteringPointsAf();
    method public java.util.List<androidx.camera.core.MeteringPoint!> getMeteringPointsAwb();
    method public boolean isAutoCancelEnabled();
    field public static final int FLAG_AE = 2; // 0x2
    field public static final int FLAG_AF = 1; // 0x1
    field public static final int FLAG_AWB = 4; // 0x4
  }

  public static class FocusMeteringAction.Builder {
    method public androidx.camera.core.FocusMeteringAction.Builder addPoint(androidx.camera.core.MeteringPoint);
    method public androidx.camera.core.FocusMeteringAction.Builder addPoint(androidx.camera.core.MeteringPoint, @androidx.camera.core.FocusMeteringAction.MeteringMode int);
    method public androidx.camera.core.FocusMeteringAction build();
    method public androidx.camera.core.FocusMeteringAction.Builder disableAutoCancel();
    method public static androidx.camera.core.FocusMeteringAction.Builder from(androidx.camera.core.MeteringPoint);
    method public static androidx.camera.core.FocusMeteringAction.Builder from(androidx.camera.core.MeteringPoint, @androidx.camera.core.FocusMeteringAction.MeteringMode int);
    method public androidx.camera.core.FocusMeteringAction.Builder setAutoCancelDuration(@IntRange(from=1) long, java.util.concurrent.TimeUnit);
  }

  @IntDef(flag=true, value={androidx.camera.core.FocusMeteringAction.FLAG_AF, androidx.camera.core.FocusMeteringAction.FLAG_AE, androidx.camera.core.FocusMeteringAction.FLAG_AWB}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface FocusMeteringAction.MeteringMode {
  }

  public final class FocusMeteringResult {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.FocusMeteringResult create(boolean);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.FocusMeteringResult emptyInstance();
    method public boolean isFocusSuccessful();
  }

  public final class ImageAnalysis extends androidx.camera.core.UseCase {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void clear();
    method public void clearAnalyzer();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected java.util.Map<java.lang.String!,android.util.Size!> onSuggestedResolutionUpdated(java.util.Map<java.lang.String!,android.util.Size!>);
    method public void setAnalyzer(java.util.concurrent.Executor, androidx.camera.core.ImageAnalysis.Analyzer);
    method public void setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.ImageAnalysis.Defaults! DEFAULT_CONFIG;
    field public static final int STRATEGY_BLOCK_PRODUCER = 1; // 0x1
    field public static final int STRATEGY_KEEP_ONLY_LATEST = 0; // 0x0
  }

  public static interface ImageAnalysis.Analyzer {
    method public void analyze(androidx.camera.core.ImageProxy);
  }

  @IntDef({androidx.camera.core.ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST, androidx.camera.core.ImageAnalysis.STRATEGY_BLOCK_PRODUCER}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface ImageAnalysis.BackpressureStrategy {
  }

  public static final class ImageAnalysis.Builder implements androidx.camera.core.ImageOutputConfig.Builder<androidx.camera.core.ImageAnalysis.Builder> androidx.camera.core.UseCaseConfig.Builder<androidx.camera.core.ImageAnalysis,androidx.camera.core.ImageAnalysisConfig,androidx.camera.core.ImageAnalysis.Builder> {
    ctor public ImageAnalysis.Builder();
    method public androidx.camera.core.ImageAnalysis build();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.ImageAnalysis.Builder fromConfig(androidx.camera.core.ImageAnalysisConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.MutableConfig getMutableConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysisConfig getUseCaseConfig();
    method public androidx.camera.core.ImageAnalysis.Builder setBackgroundExecutor(java.util.concurrent.Executor);
    method public androidx.camera.core.ImageAnalysis.Builder setBackpressureStrategy(@androidx.camera.core.ImageAnalysis.BackpressureStrategy int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setCameraIdFilter(androidx.camera.core.impl.CameraIdFilter);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setDefaultCaptureConfig(androidx.camera.core.CaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setDefaultResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setDefaultSessionConfig(androidx.camera.core.SessionConfig);
    method public androidx.camera.core.ImageAnalysis.Builder setImageQueueDepth(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setLensFacing(@androidx.camera.core.CameraSelector.LensFacing int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setMaxResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setSurfaceOccupancyPriority(int);
    method public androidx.camera.core.ImageAnalysis.Builder setTargetAspectRatio(@androidx.camera.core.AspectRatio.Ratio int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setTargetAspectRatioCustom(android.util.Rational);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setTargetClass(Class<androidx.camera.core.ImageAnalysis!>);
    method public androidx.camera.core.ImageAnalysis.Builder setTargetName(String);
    method public androidx.camera.core.ImageAnalysis.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.ImageAnalysis.Builder setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageAnalysis.Builder setUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class ImageAnalysis.Defaults implements androidx.camera.core.ConfigProvider<androidx.camera.core.ImageAnalysisConfig> {
    ctor public ImageAnalysis.Defaults();
    method public androidx.camera.core.ImageAnalysisConfig getConfig(Integer?);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class ImageAnalysisConfig implements androidx.camera.core.ImageOutputConfig androidx.camera.core.UseCaseConfig<androidx.camera.core.ImageAnalysis> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean containsOption(androidx.camera.core.Config.Option<?>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void findOptions(String, androidx.camera.core.Config.OptionMatcher);
    method public java.util.concurrent.Executor? getBackgroundExecutor(java.util.concurrent.Executor?);
    method public java.util.concurrent.Executor getBackgroundExecutor();
    method @androidx.camera.core.ImageAnalysis.BackpressureStrategy public int getBackpressureStrategy(@androidx.camera.core.ImageAnalysis.BackpressureStrategy int);
    method @androidx.camera.core.ImageAnalysis.BackpressureStrategy public int getBackpressureStrategy();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter? getCameraIdFilter(androidx.camera.core.impl.CameraIdFilter?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter getCameraIdFilter();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker? getCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker getCaptureOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig? getDefaultCaptureConfig(androidx.camera.core.CaptureConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig getDefaultCaptureConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getDefaultResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getDefaultResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig? getDefaultSessionConfig(androidx.camera.core.SessionConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig getDefaultSessionConfig();
    method public int getImageQueueDepth(int);
    method public int getImageQueueDepth();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer? getLensFacing(Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.CameraSelector.LensFacing public int getLensFacing();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getMaxResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getMaxResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker? getSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker getSessionOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>? getSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!> getSupportedResolutions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority();
    method @androidx.camera.core.AspectRatio.Ratio public int getTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational? getTargetAspectRatioCustom(android.util.Rational?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational getTargetAspectRatioCustom();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.ImageAnalysis!>? getTargetClass(Class<androidx.camera.core.ImageAnalysis!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.ImageAnalysis!> getTargetClass();
    method public String? getTargetName(String?);
    method public String getTargetName();
    method public android.util.Size? getTargetResolution(android.util.Size?);
    method public android.util.Size getTargetResolution();
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation(int);
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback? getUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback getUseCaseEventCallback();
    method public boolean hasTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<androidx.camera.core.Config.Option<?>!> listOptions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>, ValueT?);
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.util.concurrent.Executor!>! OPTION_BACKGROUND_EXECUTOR;
    field public static final androidx.camera.core.Config.Option<androidx.camera.core.impl.CameraIdFilter!>! OPTION_CAMERA_ID_FILTER;
    field public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_LENS_FACING;
    field public static final androidx.camera.core.Config.Option<java.lang.Class<?>!>! OPTION_TARGET_CLASS;
    field public static final androidx.camera.core.Config.Option<java.lang.String!>! OPTION_TARGET_NAME;
  }

  public class ImageCapture extends androidx.camera.core.UseCase {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void clear();
    method @androidx.camera.core.ImageCapture.FlashMode public int getFlashMode();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected java.util.Map<java.lang.String!,android.util.Size!> onSuggestedResolutionUpdated(java.util.Map<java.lang.String!,android.util.Size!>);
    method public void setFlashMode(@androidx.camera.core.ImageCapture.FlashMode int);
    method public void setTargetAspectRatioCustom(android.util.Rational);
    method public void setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method public void takePicture(java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageCapturedCallback);
    method public void takePicture(java.io.File, java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageSavedCallback);
    method public void takePicture(java.io.File, androidx.camera.core.ImageCapture.Metadata, java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageSavedCallback);
    field public static final int CAPTURE_MODE_MAXIMIZE_QUALITY = 0; // 0x0
    field public static final int CAPTURE_MODE_MINIMIZE_LATENCY = 1; // 0x1
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.ImageCapture.Defaults! DEFAULT_CONFIG;
    field public static final int ERROR_CAMERA_CLOSED = 3; // 0x3
    field public static final int ERROR_CAPTURE_FAILED = 2; // 0x2
    field public static final int ERROR_FILE_IO = 1; // 0x1
    field public static final int ERROR_INVALID_CAMERA = 4; // 0x4
    field public static final int ERROR_UNKNOWN = 0; // 0x0
    field public static final int FLASH_MODE_AUTO = 0; // 0x0
    field public static final int FLASH_MODE_OFF = 2; // 0x2
    field public static final int FLASH_MODE_ON = 1; // 0x1
  }

  public static final class ImageCapture.Builder implements androidx.camera.core.ImageOutputConfig.Builder<androidx.camera.core.ImageCapture.Builder> androidx.camera.core.UseCaseConfig.Builder<androidx.camera.core.ImageCapture,androidx.camera.core.ImageCaptureConfig,androidx.camera.core.ImageCapture.Builder> {
    ctor public ImageCapture.Builder();
    method public androidx.camera.core.ImageCapture build();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.ImageCapture.Builder fromConfig(androidx.camera.core.ImageCaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.MutableConfig getMutableConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCaptureConfig getUseCaseConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setBufferFormat(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setCameraIdFilter(androidx.camera.core.impl.CameraIdFilter);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setCaptureBundle(androidx.camera.core.CaptureBundle);
    method public androidx.camera.core.ImageCapture.Builder setCaptureMode(@androidx.camera.core.ImageCapture.CaptureMode int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setCaptureProcessor(androidx.camera.core.CaptureProcessor);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setDefaultCaptureConfig(androidx.camera.core.CaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setDefaultResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setDefaultSessionConfig(androidx.camera.core.SessionConfig);
    method public androidx.camera.core.ImageCapture.Builder setFlashMode(@androidx.camera.core.ImageCapture.FlashMode int);
    method public androidx.camera.core.ImageCapture.Builder setIoExecutor(java.util.concurrent.Executor);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setLensFacing(@androidx.camera.core.CameraSelector.LensFacing int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setMaxCaptureStages(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setMaxResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setSurfaceOccupancyPriority(int);
    method public androidx.camera.core.ImageCapture.Builder setTargetAspectRatio(@androidx.camera.core.AspectRatio.Ratio int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setTargetAspectRatioCustom(android.util.Rational);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setTargetClass(Class<androidx.camera.core.ImageCapture!>);
    method public androidx.camera.core.ImageCapture.Builder setTargetName(String);
    method public androidx.camera.core.ImageCapture.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.ImageCapture.Builder setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.ImageCapture.Builder setUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback);
  }

  @IntDef({androidx.camera.core.ImageCapture.CAPTURE_MODE_MAXIMIZE_QUALITY, androidx.camera.core.ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface ImageCapture.CaptureMode {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class ImageCapture.Defaults implements androidx.camera.core.ConfigProvider<androidx.camera.core.ImageCaptureConfig> {
    ctor public ImageCapture.Defaults();
    method public androidx.camera.core.ImageCaptureConfig! getConfig(Integer?);
  }

  @IntDef({androidx.camera.core.ImageCapture.FLASH_MODE_AUTO, androidx.camera.core.ImageCapture.FLASH_MODE_ON, androidx.camera.core.ImageCapture.FLASH_MODE_OFF}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface ImageCapture.FlashMode {
  }

  @IntDef({androidx.camera.core.ImageCapture.ERROR_UNKNOWN, androidx.camera.core.ImageCapture.ERROR_FILE_IO, androidx.camera.core.ImageCapture.ERROR_CAPTURE_FAILED, androidx.camera.core.ImageCapture.ERROR_CAMERA_CLOSED, androidx.camera.core.ImageCapture.ERROR_INVALID_CAMERA}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface ImageCapture.ImageCaptureError {
  }

  public static final class ImageCapture.Metadata {
    ctor public ImageCapture.Metadata();
    method public android.location.Location? getLocation();
    method public boolean isReversedHorizontal();
    method public boolean isReversedVertical();
    method public void setLocation(android.location.Location?);
    method public void setReversedHorizontal(boolean);
    method public void setReversedVertical(boolean);
  }

  public abstract static class ImageCapture.OnImageCapturedCallback {
    ctor public ImageCapture.OnImageCapturedCallback();
    method public void onCaptureSuccess(androidx.camera.core.ImageProxy);
    method public void onError(@androidx.camera.core.ImageCapture.ImageCaptureError int, String, Throwable?);
  }

  public static interface ImageCapture.OnImageSavedCallback {
    method public void onError(@androidx.camera.core.ImageCapture.ImageCaptureError int, String, Throwable?);
    method public void onImageSaved(java.io.File);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class ImageCaptureConfig implements androidx.camera.core.ImageOutputConfig androidx.camera.core.UseCaseConfig<androidx.camera.core.ImageCapture> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean containsOption(androidx.camera.core.Config.Option<?>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void findOptions(String, androidx.camera.core.Config.OptionMatcher);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer? getBufferFormat(Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer getBufferFormat();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter? getCameraIdFilter(androidx.camera.core.impl.CameraIdFilter?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter getCameraIdFilter();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureBundle? getCaptureBundle(androidx.camera.core.CaptureBundle?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureBundle getCaptureBundle();
    method @androidx.camera.core.ImageCapture.CaptureMode public int getCaptureMode();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker? getCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker getCaptureOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureProcessor? getCaptureProcessor(androidx.camera.core.CaptureProcessor?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureProcessor getCaptureProcessor();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig? getDefaultCaptureConfig(androidx.camera.core.CaptureConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig getDefaultCaptureConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getDefaultResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getDefaultResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig? getDefaultSessionConfig(androidx.camera.core.SessionConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig getDefaultSessionConfig();
    method @androidx.camera.core.ImageCapture.FlashMode public int getFlashMode();
    method public java.util.concurrent.Executor? getIoExecutor(java.util.concurrent.Executor?);
    method public java.util.concurrent.Executor getIoExecutor();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer? getLensFacing(Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.CameraSelector.LensFacing public int getLensFacing();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getMaxCaptureStages(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getMaxCaptureStages();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getMaxResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getMaxResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker? getSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker getSessionOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>? getSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!> getSupportedResolutions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority();
    method @androidx.camera.core.AspectRatio.Ratio public int getTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational? getTargetAspectRatioCustom(android.util.Rational?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational getTargetAspectRatioCustom();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.ImageCapture!>? getTargetClass(Class<androidx.camera.core.ImageCapture!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.ImageCapture!> getTargetClass();
    method public String? getTargetName(String?);
    method public String getTargetName();
    method public android.util.Size? getTargetResolution(android.util.Size?);
    method public android.util.Size getTargetResolution();
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation(int);
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback? getUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback getUseCaseEventCallback();
    method public boolean hasCaptureMode();
    method public boolean hasTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<androidx.camera.core.Config.Option<?>!> listOptions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>, ValueT?);
    field public static final androidx.camera.core.Config.Option<androidx.camera.core.impl.CameraIdFilter!>! OPTION_CAMERA_ID_FILTER;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.util.concurrent.Executor!>! OPTION_IO_EXECUTOR;
    field public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_LENS_FACING;
    field public static final androidx.camera.core.Config.Option<java.lang.Class<?>!>! OPTION_TARGET_CLASS;
    field public static final androidx.camera.core.Config.Option<java.lang.String!>! OPTION_TARGET_NAME;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class ImageFormatConstants {
    field public static final int INTERNAL_DEFINED_IMAGE_FORMAT_JPEG = 33; // 0x21
    field public static final int INTERNAL_DEFINED_IMAGE_FORMAT_PRIVATE = 34; // 0x22
  }

  public interface ImageInfo {
    method public int getRotationDegrees();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Object? getTag();
    method public long getTimestamp();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface ImageInfoProcessor {
    method public androidx.camera.core.CaptureStage! getCaptureStage();
    method public boolean process(androidx.camera.core.ImageInfo!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface ImageOutputConfig {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getDefaultResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getDefaultResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getMaxResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getMaxResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>? getSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!> getSupportedResolutions();
    method @androidx.camera.core.AspectRatio.Ratio public int getTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational? getTargetAspectRatioCustom(android.util.Rational?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational getTargetAspectRatioCustom();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getTargetResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getTargetResolution();
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation(int);
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation();
    method public boolean hasTargetAspectRatio();
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final int INVALID_ROTATION = -1; // 0xffffffff
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<android.util.Size!>! OPTION_DEFAULT_RESOLUTION;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<android.util.Size!>! OPTION_MAX_RESOLUTION;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>!>! OPTION_SUPPORTED_RESOLUTIONS;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_TARGET_ASPECT_RATIO;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<android.util.Rational!>! OPTION_TARGET_ASPECT_RATIO_CUSTOM;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<android.util.Size!>! OPTION_TARGET_RESOLUTION;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_TARGET_ROTATION;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface ImageOutputConfig.Builder<B> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setDefaultResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setMaxResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>);
    method public B setTargetAspectRatio(@androidx.camera.core.AspectRatio.Ratio int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setTargetAspectRatioCustom(android.util.Rational);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setTargetResolution(android.util.Size);
    method public B setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
  }

  @IntDef({android.view.Surface.ROTATION_0, android.view.Surface.ROTATION_90, android.view.Surface.ROTATION_180, android.view.Surface.ROTATION_270}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface ImageOutputConfig.RotationValue {
  }

  public interface ImageProxy extends java.lang.AutoCloseable {
    method public void close();
    method public android.graphics.Rect getCropRect();
    method public int getFormat();
    method public int getHeight();
    method public androidx.camera.core.ImageInfo getImageInfo();
    method public androidx.camera.core.ImageProxy.PlaneProxy![] getPlanes();
    method public int getWidth();
    method public void setCropRect(android.graphics.Rect?);
  }

  public static interface ImageProxy.PlaneProxy {
    method public java.nio.ByteBuffer getBuffer();
    method public int getPixelStride();
    method public int getRowStride();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface ImageProxyBundle {
    method public java.util.List<java.lang.Integer!> getCaptureIds();
    method public com.google.common.util.concurrent.ListenableFuture<androidx.camera.core.ImageProxy!> getImageProxy(int);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface ImageReaderProxy {
    method public androidx.camera.core.ImageProxy? acquireLatestImage();
    method public androidx.camera.core.ImageProxy? acquireNextImage();
    method public void close();
    method public int getHeight();
    method public int getImageFormat();
    method public int getMaxImages();
    method public android.view.Surface! getSurface();
    method public int getWidth();
    method public void setOnImageAvailableListener(androidx.camera.core.ImageReaderProxy.OnImageAvailableListener, android.os.Handler?);
    method public void setOnImageAvailableListener(androidx.camera.core.ImageReaderProxy.OnImageAvailableListener, java.util.concurrent.Executor);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface ImageReaderProxy.OnImageAvailableListener {
    method public void onImageAvailable(androidx.camera.core.ImageReaderProxy!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class ImageReaderProxys {
    method public static androidx.camera.core.ImageReaderProxy createIsolatedReader(int, int, int, int);
    method public static androidx.camera.core.ImageReaderProxy createSharedReader(androidx.camera.core.impl.CameraDeviceSurfaceManager, String, int, int, int, int, java.util.concurrent.Executor);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class ImmediateSurface extends androidx.camera.core.DeferrableSurface {
    ctor public ImmediateSurface(android.view.Surface);
    method public com.google.common.util.concurrent.ListenableFuture<android.view.Surface!> provideSurface();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class LensFacingConverter {
    method public static String nameOf(@androidx.camera.core.CameraSelector.LensFacing int);
    method @androidx.camera.core.CameraSelector.LensFacing public static int valueOf(String?);
    method public static Integer![] values();
  }

  public class MeteringPoint {
    method public float getSize();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational? getSurfaceAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public float getX();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public float getY();
  }

  public abstract class MeteringPointFactory {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public MeteringPointFactory();
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public MeteringPointFactory(android.util.Rational?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected abstract android.graphics.PointF convertPoint(float, float);
    method public final androidx.camera.core.MeteringPoint createPoint(float, float);
    method public final androidx.camera.core.MeteringPoint createPoint(float, float, float);
    method public static float getDefaultPointSize();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface MutableConfig extends androidx.camera.core.Config {
    method public <ValueT> void insertOption(androidx.camera.core.Config.Option<ValueT!>!, ValueT!);
    method public <ValueT> ValueT? removeOption(androidx.camera.core.Config.Option<ValueT!>!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class MutableOptionsBundle extends androidx.camera.core.OptionsBundle implements androidx.camera.core.MutableConfig {
    method public static androidx.camera.core.MutableOptionsBundle! create();
    method public static androidx.camera.core.MutableOptionsBundle! from(androidx.camera.core.Config!);
    method public <ValueT> void insertOption(androidx.camera.core.Config.Option<ValueT!>!, ValueT!);
    method public <ValueT> ValueT? removeOption(androidx.camera.core.Config.Option<ValueT!>!);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class OptionsBundle implements androidx.camera.core.Config {
    method public boolean containsOption(androidx.camera.core.Config.Option<?>);
    method public static androidx.camera.core.OptionsBundle emptyBundle();
    method public void findOptions(String, androidx.camera.core.Config.OptionMatcher);
    method public static androidx.camera.core.OptionsBundle from(androidx.camera.core.Config);
    method public java.util.Set<androidx.camera.core.Config.Option<?>!> listOptions();
    method public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>);
    method public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>, ValueT?);
    field protected final java.util.TreeMap<androidx.camera.core.Config.Option<?>!,java.lang.Object!>! mOptions;
  }

  public class Preview extends androidx.camera.core.UseCase {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void clear();
    method @UiThread public androidx.camera.core.Preview.PreviewSurfaceProvider? getPreviewSurfaceProvider();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected java.util.Map<java.lang.String!,android.util.Size!> onSuggestedResolutionUpdated(java.util.Map<java.lang.String!,android.util.Size!>);
    method @UiThread public void setPreviewSurfaceProvider(java.util.concurrent.Executor, androidx.camera.core.Preview.PreviewSurfaceProvider?);
    method @UiThread public void setPreviewSurfaceProvider(androidx.camera.core.Preview.PreviewSurfaceProvider?);
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Preview.Defaults! DEFAULT_CONFIG;
  }

  public static final class Preview.Builder implements androidx.camera.core.ImageOutputConfig.Builder<androidx.camera.core.Preview.Builder> androidx.camera.core.UseCaseConfig.Builder<androidx.camera.core.Preview,androidx.camera.core.PreviewConfig,androidx.camera.core.Preview.Builder> {
    ctor public Preview.Builder();
    method public androidx.camera.core.Preview build();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static androidx.camera.core.Preview.Builder fromConfig(androidx.camera.core.PreviewConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.MutableConfig getMutableConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.PreviewConfig getUseCaseConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setBackgroundExecutor(java.util.concurrent.Executor);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setCameraIdFilter(androidx.camera.core.impl.CameraIdFilter);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setCaptureProcessor(androidx.camera.core.CaptureProcessor);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setDefaultCaptureConfig(androidx.camera.core.CaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setDefaultResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setDefaultSessionConfig(androidx.camera.core.SessionConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setImageInfoProcessor(androidx.camera.core.ImageInfoProcessor);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setLensFacing(@androidx.camera.core.CameraSelector.LensFacing int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setMaxResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setSurfaceOccupancyPriority(int);
    method public androidx.camera.core.Preview.Builder setTargetAspectRatio(@androidx.camera.core.AspectRatio.Ratio int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setTargetAspectRatioCustom(android.util.Rational);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setTargetClass(Class<androidx.camera.core.Preview!>);
    method public androidx.camera.core.Preview.Builder setTargetName(String);
    method public androidx.camera.core.Preview.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.Preview.Builder setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.Preview.Builder setUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class Preview.Defaults implements androidx.camera.core.ConfigProvider<androidx.camera.core.PreviewConfig> {
    ctor public Preview.Defaults();
    method public androidx.camera.core.PreviewConfig! getConfig(Integer?);
  }

  public static interface Preview.PreviewSurfaceProvider {
    method public com.google.common.util.concurrent.ListenableFuture<android.view.Surface!> provideSurface(android.util.Size, com.google.common.util.concurrent.ListenableFuture<java.lang.Void!>);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class PreviewConfig implements androidx.camera.core.ImageOutputConfig androidx.camera.core.UseCaseConfig<androidx.camera.core.Preview> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean containsOption(androidx.camera.core.Config.Option<?>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void findOptions(String, androidx.camera.core.Config.OptionMatcher);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.concurrent.Executor? getBackgroundExecutor(java.util.concurrent.Executor?);
    method public java.util.concurrent.Executor getBackgroundExecutor();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter? getCameraIdFilter(androidx.camera.core.impl.CameraIdFilter?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter getCameraIdFilter();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker? getCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker getCaptureOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureProcessor? getCaptureProcessor(androidx.camera.core.CaptureProcessor?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureProcessor getCaptureProcessor();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig? getDefaultCaptureConfig(androidx.camera.core.CaptureConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig getDefaultCaptureConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getDefaultResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getDefaultResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig? getDefaultSessionConfig(androidx.camera.core.SessionConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig getDefaultSessionConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer? getLensFacing(Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.CameraSelector.LensFacing public int getLensFacing();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getMaxResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getMaxResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker? getSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker getSessionOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>? getSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!> getSupportedResolutions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority();
    method @androidx.camera.core.AspectRatio.Ratio public int getTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational? getTargetAspectRatioCustom(android.util.Rational?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational getTargetAspectRatioCustom();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.Preview!>? getTargetClass(Class<androidx.camera.core.Preview!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.Preview!> getTargetClass();
    method public String? getTargetName(String?);
    method public String getTargetName();
    method public android.util.Size? getTargetResolution(android.util.Size?);
    method public android.util.Size getTargetResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback? getUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback getUseCaseEventCallback();
    method public boolean hasTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<androidx.camera.core.Config.Option<?>!> listOptions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>, ValueT?);
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.util.concurrent.Executor!>! OPTION_BACKGROUND_EXECUTOR;
    field public static final androidx.camera.core.Config.Option<androidx.camera.core.impl.CameraIdFilter!>! OPTION_CAMERA_ID_FILTER;
    field public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_LENS_FACING;
    field public static final androidx.camera.core.Config.Option<java.lang.Class<?>!>! OPTION_TARGET_CLASS;
    field public static final androidx.camera.core.Config.Option<java.lang.String!>! OPTION_TARGET_NAME;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class SessionConfig {
    method public static androidx.camera.core.SessionConfig defaultEmptySessionConfig();
    method public java.util.List<android.hardware.camera2.CameraDevice.StateCallback!> getDeviceStateCallbacks();
    method public java.util.List<androidx.camera.core.SessionConfig.ErrorListener!> getErrorListeners();
    method public androidx.camera.core.Config getImplementationOptions();
    method public java.util.List<androidx.camera.core.impl.CameraCaptureCallback!> getRepeatingCameraCaptureCallbacks();
    method public androidx.camera.core.CaptureConfig getRepeatingCaptureConfig();
    method public java.util.List<android.hardware.camera2.CameraCaptureSession.StateCallback!> getSessionStateCallbacks();
    method public java.util.List<androidx.camera.core.impl.CameraCaptureCallback!> getSingleCameraCaptureCallbacks();
    method public java.util.List<androidx.camera.core.DeferrableSurface!> getSurfaces();
    method public int getTemplateType();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static class SessionConfig.Builder {
    ctor public SessionConfig.Builder();
    method public void addAllCameraCaptureCallbacks(java.util.Collection<androidx.camera.core.impl.CameraCaptureCallback!>);
    method public void addAllDeviceStateCallbacks(java.util.Collection<android.hardware.camera2.CameraDevice.StateCallback!>);
    method public void addAllRepeatingCameraCaptureCallbacks(java.util.Collection<androidx.camera.core.impl.CameraCaptureCallback!>);
    method public void addAllSessionStateCallbacks(java.util.List<android.hardware.camera2.CameraCaptureSession.StateCallback!>);
    method public void addCameraCaptureCallback(androidx.camera.core.impl.CameraCaptureCallback);
    method public void addDeviceStateCallback(android.hardware.camera2.CameraDevice.StateCallback);
    method public void addErrorListener(androidx.camera.core.SessionConfig.ErrorListener);
    method public void addImplementationOptions(androidx.camera.core.Config);
    method public void addNonRepeatingSurface(androidx.camera.core.DeferrableSurface);
    method public void addRepeatingCameraCaptureCallback(androidx.camera.core.impl.CameraCaptureCallback);
    method public void addSessionStateCallback(android.hardware.camera2.CameraCaptureSession.StateCallback);
    method public void addSurface(androidx.camera.core.DeferrableSurface);
    method public androidx.camera.core.SessionConfig build();
    method public void clearSurfaces();
    method public static androidx.camera.core.SessionConfig.Builder createFrom(androidx.camera.core.UseCaseConfig<?>);
    method public java.util.List<androidx.camera.core.impl.CameraCaptureCallback!> getSingleCameraCaptureCallbacks();
    method public void removeSurface(androidx.camera.core.DeferrableSurface);
    method public void setImplementationOptions(androidx.camera.core.Config!);
    method public void setTag(Object!);
    method public void setTemplateType(int);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface SessionConfig.ErrorListener {
    method public void onError(androidx.camera.core.SessionConfig, androidx.camera.core.SessionConfig.SessionError);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface SessionConfig.OptionUnpacker {
    method public void unpack(androidx.camera.core.UseCaseConfig<?>, androidx.camera.core.SessionConfig.Builder);
  }

  public enum SessionConfig.SessionError {
    enum_constant public static final androidx.camera.core.SessionConfig.SessionError SESSION_ERROR_SURFACE_NEEDS_RESET;
    enum_constant public static final androidx.camera.core.SessionConfig.SessionError SESSION_ERROR_UNKNOWN;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class SessionConfig.ValidatingBuilder {
    ctor public SessionConfig.ValidatingBuilder();
    method public void add(androidx.camera.core.SessionConfig);
    method public androidx.camera.core.SessionConfig build();
    method public boolean isValid();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class SingleImageProxyBundle implements androidx.camera.core.ImageProxyBundle {
    ctor public SingleImageProxyBundle(androidx.camera.core.ImageProxy);
    method public java.util.List<java.lang.Integer!> getCaptureIds();
    method public com.google.common.util.concurrent.ListenableFuture<androidx.camera.core.ImageProxy!> getImageProxy(int);
  }

  public class SurfaceOrientedMeteringPointFactory extends androidx.camera.core.MeteringPointFactory {
    ctor public SurfaceOrientedMeteringPointFactory(float, float);
    ctor public SurfaceOrientedMeteringPointFactory(float, float, androidx.camera.core.UseCase);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected android.graphics.PointF convertPoint(float, float);
  }

  public class TorchState {
    field public static final int OFF = 0; // 0x0
    field public static final int ON = 1; // 0x1
  }

  @IntDef({androidx.camera.core.TorchState.OFF, androidx.camera.core.TorchState.ON}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface TorchState.State {
  }

  public abstract class UseCase {
    ctor @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected UseCase(androidx.camera.core.UseCaseConfig<?>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void addStateChangeCallback(androidx.camera.core.UseCase.StateChangeCallback);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected androidx.camera.core.UseCaseConfig<?> applyDefaults(androidx.camera.core.UseCaseConfig<?>, androidx.camera.core.UseCaseConfig.Builder<?,?,?>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final void attachCameraControl(String!, androidx.camera.core.impl.CameraControlInternal!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected void attachToCamera(String!, androidx.camera.core.SessionConfig!);
    method @CallSuper @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected void clear();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<java.lang.String!>! getAttachedCameraIds();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size! getAttachedSurfaceResolution(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraInternal? getBoundCamera();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected String getBoundCameraId();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected androidx.camera.core.impl.CameraControlInternal! getCameraControl(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected androidx.camera.core.UseCaseConfig.Builder<?,?,?>? getDefaultBuilder(Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getImageFormat();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public String getName();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig! getSessionConfig(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCaseConfig<?>! getUseCaseConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected boolean isCurrentlyBoundCamera(String);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected final void notifyActive();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected final void notifyInactive();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected final void notifyReset();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected final void notifyState();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected final void notifyUpdated();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected void onBind(androidx.camera.core.impl.CameraInternal);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected void onCameraControlReady(String!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void onStateOffline(String);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void onStateOnline(String);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected abstract java.util.Map<java.lang.String!,android.util.Size!> onSuggestedResolutionUpdated(java.util.Map<java.lang.String!,android.util.Size!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void removeStateChangeCallback(androidx.camera.core.UseCase.StateChangeCallback);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected void setImageFormat(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void updateSuggestedResolution(java.util.Map<java.lang.String!,android.util.Size!>!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected final void updateUseCaseConfig(androidx.camera.core.UseCaseConfig<?>);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface UseCase.EventCallback {
    method public void onBind(String);
    method public void onUnbind();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface UseCase.StateChangeCallback {
    method public void onUseCaseActive(androidx.camera.core.UseCase);
    method public void onUseCaseInactive(androidx.camera.core.UseCase);
    method public void onUseCaseReset(androidx.camera.core.UseCase);
    method public void onUseCaseUpdated(androidx.camera.core.UseCase);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface UseCaseConfig<T extends androidx.camera.core.UseCase> extends androidx.camera.core.Config androidx.camera.core.UseCaseEventConfig {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker? getCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker getCaptureOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig? getDefaultCaptureConfig(androidx.camera.core.CaptureConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig getDefaultCaptureConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig? getDefaultSessionConfig(androidx.camera.core.SessionConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig getDefaultSessionConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker? getSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker getSessionOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority();
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<androidx.camera.core.CaptureConfig.OptionUnpacker!>! OPTION_CAPTURE_CONFIG_UNPACKER;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<androidx.camera.core.CaptureConfig!>! OPTION_DEFAULT_CAPTURE_CONFIG;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<androidx.camera.core.SessionConfig!>! OPTION_DEFAULT_SESSION_CONFIG;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<androidx.camera.core.SessionConfig.OptionUnpacker!>! OPTION_SESSION_CONFIG_UNPACKER;
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_SURFACE_OCCUPANCY_PRIORITY;
    field public static final androidx.camera.core.Config.Option<java.lang.Class<?>!>! OPTION_TARGET_CLASS;
    field public static final androidx.camera.core.Config.Option<java.lang.String!>! OPTION_TARGET_NAME;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface UseCaseConfig.Builder<T extends androidx.camera.core.UseCase, C extends androidx.camera.core.UseCaseConfig<T>, B> extends androidx.camera.core.ExtendableBuilder<T> androidx.camera.core.UseCaseEventConfig.Builder<B> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public C getUseCaseConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setDefaultCaptureConfig(androidx.camera.core.CaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setDefaultSessionConfig(androidx.camera.core.SessionConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setSurfaceOccupancyPriority(int);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface UseCaseConfigFactory {
    method public <C extends androidx.camera.core.UseCaseConfig<?>> C? getConfig(Class<C!>, Integer?);
  }

  public static interface UseCaseConfigFactory.Provider {
    method public androidx.camera.core.UseCaseConfigFactory newInstance(android.content.Context);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public interface UseCaseEventConfig {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback? getUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback getUseCaseEventCallback();
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<androidx.camera.core.UseCase.EventCallback!>! OPTION_USE_CASE_EVENT_CALLBACK;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static interface UseCaseEventConfig.Builder<B> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public B setUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class UseCaseGroup {
    ctor public UseCaseGroup();
    method public boolean addUseCase(androidx.camera.core.UseCase!);
    method public void clear();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public class VideoCapture extends androidx.camera.core.UseCase {
    ctor public VideoCapture(androidx.camera.core.VideoCaptureConfig!);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void clear();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) protected java.util.Map<java.lang.String!,android.util.Size!> onSuggestedResolutionUpdated(java.util.Map<java.lang.String!,android.util.Size!>);
    method public void setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method public void startRecording(java.io.File, java.util.concurrent.Executor, androidx.camera.core.VideoCapture.OnVideoSavedCallback);
    method public void startRecording(java.io.File, androidx.camera.core.VideoCapture.Metadata, java.util.concurrent.Executor, androidx.camera.core.VideoCapture.OnVideoSavedCallback);
    method public void stopRecording();
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.VideoCapture.Defaults! DEFAULT_CONFIG;
    field public static final int ERROR_ENCODER = 1; // 0x1
    field public static final int ERROR_MUXER = 2; // 0x2
    field public static final int ERROR_RECORDING_IN_PROGRESS = 3; // 0x3
    field public static final int ERROR_UNKNOWN = 0; // 0x0
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final class VideoCapture.Defaults implements androidx.camera.core.ConfigProvider<androidx.camera.core.VideoCaptureConfig> {
    ctor public VideoCapture.Defaults();
    method public androidx.camera.core.VideoCaptureConfig! getConfig(Integer?);
  }

  public static final class VideoCapture.Metadata {
    ctor public VideoCapture.Metadata();
    field public android.location.Location? location;
  }

  public static interface VideoCapture.OnVideoSavedCallback {
    method public void onError(@androidx.camera.core.VideoCapture.VideoCaptureError int, String, Throwable?);
    method public void onVideoSaved(java.io.File);
  }

  @IntDef({androidx.camera.core.VideoCapture.ERROR_UNKNOWN, androidx.camera.core.VideoCapture.ERROR_ENCODER, androidx.camera.core.VideoCapture.ERROR_MUXER, androidx.camera.core.VideoCapture.ERROR_RECORDING_IN_PROGRESS}) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) public static @interface VideoCapture.VideoCaptureError {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class VideoCaptureConfig implements androidx.camera.core.ImageOutputConfig androidx.camera.core.UseCaseConfig<androidx.camera.core.VideoCapture> {
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public boolean containsOption(androidx.camera.core.Config.Option<?>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public void findOptions(String, androidx.camera.core.Config.OptionMatcher);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioBitRate(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioBitRate();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioChannelCount(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioChannelCount();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioMinBufferSize(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioMinBufferSize();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioRecordSource(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioRecordSource();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioSampleRate(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getAudioSampleRate();
    method public java.util.concurrent.Executor? getBackgroundExecutor(java.util.concurrent.Executor?);
    method public java.util.concurrent.Executor getBackgroundExecutor();
    method public int getBitRate(int);
    method public int getBitRate();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter? getCameraIdFilter(androidx.camera.core.impl.CameraIdFilter?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.impl.CameraIdFilter getCameraIdFilter();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker? getCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig.OptionUnpacker getCaptureOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig? getDefaultCaptureConfig(androidx.camera.core.CaptureConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.CaptureConfig getDefaultCaptureConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getDefaultResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getDefaultResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig? getDefaultSessionConfig(androidx.camera.core.SessionConfig?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig getDefaultSessionConfig();
    method public int getIFrameInterval(int);
    method public int getIFrameInterval();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Integer? getLensFacing(Integer?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @androidx.camera.core.CameraSelector.LensFacing public int getLensFacing();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getMaxResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getMaxResolution();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker? getSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.SessionConfig.OptionUnpacker getSessionOptionUnpacker();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>? getSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!> getSupportedResolutions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public int getSurfaceOccupancyPriority();
    method @androidx.camera.core.AspectRatio.Ratio public int getTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational? getTargetAspectRatioCustom(android.util.Rational?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Rational getTargetAspectRatioCustom();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.VideoCapture!>? getTargetClass(Class<androidx.camera.core.VideoCapture!>?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public Class<androidx.camera.core.VideoCapture!> getTargetClass();
    method public String? getTargetName(String?);
    method public String getTargetName();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size? getTargetResolution(android.util.Size?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public android.util.Size getTargetResolution();
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation(int);
    method @androidx.camera.core.ImageOutputConfig.RotationValue public int getTargetRotation();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback? getUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback?);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.UseCase.EventCallback getUseCaseEventCallback();
    method public int getVideoFrameRate(int);
    method public int getVideoFrameRate();
    method public boolean hasTargetAspectRatio();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public java.util.Set<androidx.camera.core.Config.Option<?>!> listOptions();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public <ValueT> ValueT? retrieveOption(androidx.camera.core.Config.Option<ValueT!>, ValueT?);
    field @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public static final androidx.camera.core.Config.Option<java.util.concurrent.Executor!>! OPTION_BACKGROUND_EXECUTOR;
    field public static final androidx.camera.core.Config.Option<androidx.camera.core.impl.CameraIdFilter!>! OPTION_CAMERA_ID_FILTER;
    field public static final androidx.camera.core.Config.Option<java.lang.Integer!>! OPTION_LENS_FACING;
    field public static final androidx.camera.core.Config.Option<java.lang.Class<?>!>! OPTION_TARGET_CLASS;
    field public static final androidx.camera.core.Config.Option<java.lang.String!>! OPTION_TARGET_NAME;
  }

  public static final class VideoCaptureConfig.Builder implements androidx.camera.core.ImageOutputConfig.Builder<androidx.camera.core.VideoCaptureConfig.Builder> androidx.camera.core.UseCaseConfig.Builder<androidx.camera.core.VideoCapture,androidx.camera.core.VideoCaptureConfig,androidx.camera.core.VideoCaptureConfig.Builder> {
    ctor public VideoCaptureConfig.Builder();
    method public androidx.camera.core.VideoCapture build();
    method public static androidx.camera.core.VideoCaptureConfig.Builder fromConfig(androidx.camera.core.VideoCaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.MutableConfig getMutableConfig();
    method public androidx.camera.core.VideoCaptureConfig getUseCaseConfig();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setAudioBitRate(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setAudioChannelCount(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setAudioMinBufferSize(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setAudioRecordSource(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setAudioSampleRate(int);
    method public androidx.camera.core.VideoCaptureConfig.Builder setBackgroundExecutor(java.util.concurrent.Executor);
    method public androidx.camera.core.VideoCaptureConfig.Builder setBitRate(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setCameraIdFilter(androidx.camera.core.impl.CameraIdFilter);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setCaptureOptionUnpacker(androidx.camera.core.CaptureConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setDefaultCaptureConfig(androidx.camera.core.CaptureConfig);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setDefaultResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setDefaultSessionConfig(androidx.camera.core.SessionConfig);
    method public androidx.camera.core.VideoCaptureConfig.Builder setIFrameInterval(int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setLensFacing(@androidx.camera.core.CameraSelector.LensFacing int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setMaxResolution(android.util.Size);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setSessionOptionUnpacker(androidx.camera.core.SessionConfig.OptionUnpacker);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer!,android.util.Size![]!>!>);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setSurfaceOccupancyPriority(int);
    method public androidx.camera.core.VideoCaptureConfig.Builder setTargetAspectRatio(@androidx.camera.core.AspectRatio.Ratio int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setTargetAspectRatioCustom(android.util.Rational);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setTargetClass(Class<androidx.camera.core.VideoCapture!>);
    method public androidx.camera.core.VideoCaptureConfig.Builder setTargetName(String);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.VideoCaptureConfig.Builder setTargetRotation(@androidx.camera.core.ImageOutputConfig.RotationValue int);
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public androidx.camera.core.VideoCaptureConfig.Builder setUseCaseEventCallback(androidx.camera.core.UseCase.EventCallback);
    method public androidx.camera.core.VideoCaptureConfig.Builder setVideoFrameRate(int);
  }

}

package @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP}) @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP}) androidx.camera.core.impl {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class LiveDataObservable<T> implements androidx.camera.core.impl.Observable<T> {
    ctor public LiveDataObservable();
    method public void addObserver(java.util.concurrent.Executor, androidx.camera.core.impl.Observable.Observer<T!>);
    method public com.google.common.util.concurrent.ListenableFuture<T!> fetchData();
    method public androidx.lifecycle.LiveData<androidx.camera.core.impl.LiveDataObservable.Result<T!>!> getLiveData();
    method public void postError(Throwable);
    method public void postValue(T?);
    method public void removeObserver(androidx.camera.core.impl.Observable.Observer<T!>);
  }

  public static final class LiveDataObservable.Result<T> {
    method public boolean completedSuccessfully();
    method public Throwable? getError();
    method public T? getValue();
  }

}

package @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP}) @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP}) androidx.camera.core.impl.annotation {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.SOURCE) @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD) public @interface ExecutedBy {
    method public abstract String value();
  }

}

package @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP}) @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP}) androidx.camera.core.impl.utils {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class MainThreadAsyncHandler {
    method public static android.os.Handler! getInstance();
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP) public final class Threads {
    method public static void checkBackgroundThread();
    method public static void checkMainThread();
    method public static boolean isBackgroundThread();
    method public static boolean isMainThread();
  }

}

