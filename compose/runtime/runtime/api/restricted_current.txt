// Signature format: 4.0
package androidx.compose.runtime {

  @androidx.compose.runtime.ExperimentalComposeApi public abstract class AbstractApplier<T> implements androidx.compose.runtime.Applier<T> {
    ctor public AbstractApplier(T? root);
    method public final void clear();
    method public void down(T? node);
    method public T! getCurrent();
    method public final T! getRoot();
    method protected final void move(java.util.List<T>, int from, int to, int count);
    method protected abstract void onClear();
    method protected final void remove(java.util.List<T>, int index, int count);
    method protected void setCurrent(T! p);
    method public void up();
    property public T! current;
    property public final T! root;
  }

  public final class ActualAndroidKt {
    method public static androidx.compose.runtime.EmbeddingContext EmbeddingContext();
  }

  public final class ActualJvmKt {
  }

  @androidx.compose.runtime.Stable public abstract sealed class Ambient<T> {
    method public final inline T! getCurrent();
    property public final inline T! current;
  }

  public final class AmbientKt {
    method @androidx.compose.runtime.Composable public static void Providers(androidx.compose.runtime.ProvidedValue<?>![] values, kotlin.jvm.functions.Function0<kotlin.Unit> children);
    method public static <T> androidx.compose.runtime.ProvidableAmbient<T> ambientOf(optional androidx.compose.runtime.SnapshotMutationPolicy<T> policy, optional kotlin.jvm.functions.Function0<? extends T>? defaultFactory);
    method public static <T> androidx.compose.runtime.ProvidableAmbient<T> staticAmbientOf(optional kotlin.jvm.functions.Function0<? extends T>? defaultFactory);
  }

  @androidx.compose.runtime.InternalComposeApi public final class Anchor {
    method public boolean getValid();
    method public int toIndexFor(androidx.compose.runtime.SlotTable slots);
    method public int toIndexFor(androidx.compose.runtime.SlotWriter writer);
    property public final boolean valid;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public interface Applier<N> {
    method public void clear();
    method public void down(N? node);
    method public N! getCurrent();
    method public void insert(int index, N? instance);
    method public void move(int from, int to, int count);
    method public void remove(int index, int count);
    method public void up();
    property public abstract N! current;
  }

  public final class BitwiseOperatorsKt {
  }

  public interface CommitScope {
    method public void onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> callback);
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface Composable {
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface ComposableContract {
    method public abstract boolean preventCapture() default false;
    method public abstract boolean readonly() default false;
    method public abstract boolean restartable() default true;
    method public abstract boolean tracked() default true;
    property public abstract boolean preventCapture;
    property public abstract boolean readonly;
    property public abstract boolean restartable;
    property public abstract boolean tracked;
  }

  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level, message="This API is intended to be targeted by the Compose Compiler Plugin and not called " + "directly.") @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface ComposeCompilerApi {
  }

  public final class ComposeKt {
    method @androidx.compose.runtime.Stable public static kotlin.jvm.functions.Function0<kotlin.Unit> emptyContent();
    method public static inline kotlin.jvm.functions.Function0<kotlin.Unit> orEmpty(kotlin.jvm.functions.Function0<kotlin.Unit>?);
  }

  public final class Composer<N> {
    ctor public Composer(androidx.compose.runtime.SlotTable slotTable, @androidx.compose.runtime.ComposeCompilerApi androidx.compose.runtime.Applier<N> applier, androidx.compose.runtime.CompositionReference parentReference);
    method @androidx.compose.runtime.InternalComposeApi public void applyChanges();
    method @androidx.compose.runtime.ComposeCompilerApi public inline <T> T! cache(boolean invalid, kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(Object? value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(char value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(byte value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(short value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(boolean value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(float value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(long value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(double value);
    method @androidx.compose.runtime.ComposeCompilerApi public boolean changed(int value);
    method @androidx.compose.runtime.InternalComposeApi public void collectKeySourceInformation();
    method @androidx.compose.runtime.InternalComposeApi public void composeInitial(kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method @androidx.compose.runtime.ComposeCompilerApi @kotlin.PublishedApi internal <T> T! consume(androidx.compose.runtime.Ambient<T> key);
    method @androidx.compose.runtime.ComposeCompilerApi public <T extends N> void createNode(kotlin.jvm.functions.Function0<? extends T> factory);
    method @androidx.compose.runtime.ComposeCompilerApi public void emitNode(Object? node);
    method @androidx.compose.runtime.ComposeCompilerApi public void endDefaults();
    method @androidx.compose.runtime.ComposeCompilerApi public void endMovableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void endNode();
    method @androidx.compose.runtime.ComposeCompilerApi public void endReplaceableGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public androidx.compose.runtime.ScopeUpdateScope? endRestartGroup();
    method public androidx.compose.runtime.Applier<N> getApplier();
    method public int getCurrentCompoundKeyHash();
    method public boolean getDefaultsInvalid();
    method public boolean getInserting();
    method public boolean getSkipping();
    method public androidx.compose.runtime.SlotTable getSlotTable();
    method @androidx.compose.runtime.ComposeCompilerApi public Object joinKey(Object? left, Object? right);
    method @androidx.compose.runtime.ComposeCompilerApi public Object? nextSlot();
    method @androidx.compose.runtime.InternalComposeApi public boolean recompose();
    method @androidx.compose.runtime.InternalComposeApi public void recordModificationsOf(java.util.Set<?> values);
    method @androidx.compose.runtime.InternalComposeApi public void recordReadOf(Object value);
    method @androidx.compose.runtime.InternalComposeApi public void recordWriteOf(Object value);
    method @androidx.compose.runtime.ComposeCompilerApi public void skipCurrentGroup();
    method @androidx.compose.runtime.ComposeCompilerApi public void skipToGroupEnd();
    method @androidx.compose.runtime.ComposeCompilerApi public void startDefaults();
    method @androidx.compose.runtime.ComposeCompilerApi public void startMovableGroup(int key, Object? dataKey);
    method @androidx.compose.runtime.ComposeCompilerApi public void startMovableGroup(int key, Object? dataKey, String? sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public void startNode();
    method @androidx.compose.runtime.ComposeCompilerApi public void startReplaceableGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public void startReplaceableGroup(int key, String? sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi public void startRestartGroup(int key);
    method @androidx.compose.runtime.ComposeCompilerApi public void startRestartGroup(int key, String? sourceInformation);
    method @androidx.compose.runtime.ComposeCompilerApi @kotlin.PublishedApi internal void updateValue(Object? value);
    method @androidx.compose.runtime.ComposeCompilerApi public N! useNode();
    property public final androidx.compose.runtime.Applier<N> applier;
    property public final int currentCompoundKeyHash;
    property public final boolean defaultsInvalid;
    property public final boolean inserting;
    property public final boolean skipping;
    property public final androidx.compose.runtime.SlotTable slotTable;
  }

  public final class ComposerKt {
    method public static androidx.compose.runtime.Composer<?> getCurrentComposer();
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.OpaqueKey ambientMap;
    field @kotlin.PublishedApi internal static final int ambientMapKey = 202; // 0xca
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.OpaqueKey invocation;
    field @kotlin.PublishedApi internal static final int invocationKey = 200; // 0xc8
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.OpaqueKey provider;
    field @kotlin.PublishedApi internal static final int providerKey = 201; // 0xc9
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.OpaqueKey providerMaps;
    field @kotlin.PublishedApi internal static final int providerMapsKey = 204; // 0xcc
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.OpaqueKey providerValues;
    field @kotlin.PublishedApi internal static final int providerValuesKey = 203; // 0xcb
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.OpaqueKey reference;
    field @kotlin.PublishedApi internal static final int referenceKey = 206; // 0xce
  }

  public interface Composition {
    method public void dispose();
    method public boolean hasInvalidations();
    method public void setContent(kotlin.jvm.functions.Function0<kotlin.Unit> content);
  }

  @Deprecated public interface CompositionFrameClock extends androidx.compose.runtime.dispatch.MonotonicFrameClock {
    method @Deprecated public default suspend <R> Object? awaitFrameNanos(kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R> p);
  }

  public final class CompositionFrameClockKt {
    method @Deprecated public static suspend inline <R> Object? awaitFrameMillis(androidx.compose.runtime.CompositionFrameClock, kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R> p);
    method @Deprecated public static suspend Object? awaitFrameMillis(androidx.compose.runtime.CompositionFrameClock, kotlin.coroutines.Continuation<? super java.lang.Long> p);
    method @Deprecated public static suspend Object? awaitFrameNanos(androidx.compose.runtime.CompositionFrameClock, kotlin.coroutines.Continuation<? super java.lang.Long> p);
    method @Deprecated public static suspend inline <R> Object? withFrameMillis(androidx.compose.runtime.CompositionFrameClock, kotlin.jvm.functions.Function1<? super java.lang.Long,? extends R> onFrame, kotlin.coroutines.Continuation<? super R> p);
  }

  public final class CompositionKt {
    method @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.Composition compositionFor(Object key, androidx.compose.runtime.Applier<?> applier, androidx.compose.runtime.CompositionReference parent, optional kotlin.jvm.functions.Function0<kotlin.Unit> onCreated);
  }

  public interface CompositionLifecycleObserver {
    method public default void onEnter();
    method public default void onLeave();
  }

  public abstract class CompositionReference {
  }

  public final class CompositionReferenceKt {
  }

  @kotlin.PublishedApi internal final class CompositionScopedCoroutineScopeCanceller implements androidx.compose.runtime.CompositionLifecycleObserver {
    ctor public CompositionScopedCoroutineScopeCanceller(kotlinx.coroutines.CoroutineScope coroutineScope);
    method public kotlinx.coroutines.CoroutineScope getCoroutineScope();
    property public final kotlinx.coroutines.CoroutineScope coroutineScope;
  }

  public final class DerivedStateKt {
    method public static <T> androidx.compose.runtime.State<T> derivedStateOf(kotlin.jvm.functions.Function0<? extends T> calculation);
  }

  public interface DisposableEffectDisposable {
    method public void dispose();
  }

  public final class DisposableEffectScope {
    ctor public DisposableEffectScope();
    method public inline androidx.compose.runtime.DisposableEffectDisposable onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> onDisposeEffect);
  }

  public final class EffectsKt {
    method @androidx.compose.runtime.Composable public static androidx.compose.runtime.CompositionReference compositionReference();
    method public static kotlin.jvm.functions.Function0<kotlin.Unit> getInvalidate();
    method @androidx.compose.runtime.Composable public static void onActive(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static inline void onCommit(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static <V1> void onCommit(V1? v1, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static <V1, V2> void onCommit(V1? v1, V2? v2, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static void onCommit(Object![]? inputs, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @androidx.compose.runtime.Composable public static void onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> callback);
    method @Deprecated @androidx.compose.runtime.Composable public static inline void onPreCommit(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @Deprecated @androidx.compose.runtime.Composable public static <V1> void onPreCommit(V1? v1, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @Deprecated @androidx.compose.runtime.Composable public static <V1, V2> void onPreCommit(V1? v1, V2? v2, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
    method @Deprecated @androidx.compose.runtime.Composable public static void onPreCommit(Object![]? inputs, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> callback);
  }

  public interface EmbeddingContext {
    method public boolean isMainThread();
    method public kotlin.coroutines.CoroutineContext mainThreadCompositionContext();
  }

  public final class EmitKt {
    method @androidx.compose.runtime.Composable public static inline <T extends java.lang.Object, reified E extends androidx.compose.runtime.Applier<?>> void emit(kotlin.jvm.functions.Function0<? extends T> ctor, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T>,? extends kotlin.Unit> update);
    method @androidx.compose.runtime.Composable public static inline <T extends java.lang.Object, reified E extends androidx.compose.runtime.Applier<?>> void emit(kotlin.jvm.functions.Function0<? extends T> ctor, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T>,? extends kotlin.Unit> update, kotlin.jvm.functions.Function0<? extends kotlin.Unit> children);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(readonly=true) public static inline <T extends java.lang.Object, reified E extends androidx.compose.runtime.Applier<?>> void emit(kotlin.jvm.functions.Function0<? extends T> ctor, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T>,? extends kotlin.Unit> update, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.SkippableUpdater<T>,? extends kotlin.Unit> skippableUpdate, kotlin.jvm.functions.Function0<? extends kotlin.Unit> children);
    method @kotlin.PublishedApi internal static void invalidApplier();
  }

  public final class ExpectKt {
  }

  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level, message="This is an experimental API for Compose and is likely to change before becoming " + "stable.") @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface ExperimentalComposeApi {
  }

  public final class FlowAdapterKt {
    method @androidx.compose.runtime.Composable @kotlinx.coroutines.ExperimentalCoroutinesApi public static inline <T> androidx.compose.runtime.State<T> collectAsState(kotlinx.coroutines.flow.StateFlow<? extends T>, optional kotlin.coroutines.CoroutineContext context);
    method @androidx.compose.runtime.Composable public static inline <T extends R, R> androidx.compose.runtime.State<R> collectAsState(kotlinx.coroutines.flow.Flow<? extends T>, R? initial, optional kotlin.coroutines.CoroutineContext context);
  }

  public final class FrameManager {
    method public void ensureStarted();
    field public static final androidx.compose.runtime.FrameManager INSTANCE;
  }

  @androidx.compose.runtime.StableMarker @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets=kotlin.annotation.AnnotationTarget) public @interface Immutable {
  }

  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level, message="This is internal API for Compose modules that may change frequently " + "and without warning.") @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface InternalComposeApi {
  }

  public final class JoinedKeyKt {
    method @androidx.compose.runtime.InternalComposeApi public static boolean isJoinedKey(Object? key);
    method @androidx.compose.runtime.InternalComposeApi public static Object? joinedKeyLeft(Object? key);
    method @androidx.compose.runtime.InternalComposeApi public static Object? joinedKeyRight(Object? key);
  }

  @androidx.compose.runtime.InternalComposeApi public final class KeyInfo {
    method public int getIndex();
    method public int getKey();
    method public int getLocation();
    method public int getNodes();
    method public Object? getObjectKey();
    property public final int index;
    property public final int key;
    property public final int location;
    property public final int nodes;
    property public final Object? objectKey;
  }

  public final class KeyKt {
    method @androidx.compose.runtime.Composable public static inline <T> T! key(Object![]? inputs, kotlin.jvm.functions.Function0<? extends T> block);
  }

  public final class KeySourceInfoKt {
    method @androidx.compose.runtime.InternalComposeApi public static String? keySourceInfoOf(Object key);
    method @androidx.compose.runtime.InternalComposeApi public static void resetSourceInfo();
  }

  @androidx.compose.runtime.Stable public interface MutableState<T> extends androidx.compose.runtime.State<T> {
    method public operator T! component1();
    method public operator kotlin.jvm.functions.Function1<T,kotlin.Unit> component2();
    method public void setValue(T! p);
    property public abstract T! value;
  }

  public final class MutableStateKt {
    method @Deprecated public static kotlin.jvm.functions.Function2<java.lang.Object,java.lang.Object,java.lang.Boolean> getNeverEqual();
    method @Deprecated public static kotlin.jvm.functions.Function2<java.lang.Object,java.lang.Object,java.lang.Boolean> getReferentiallyEqual();
    method @Deprecated public static kotlin.jvm.functions.Function2<java.lang.Object,java.lang.Object,java.lang.Boolean> getStructurallyEqual();
    method public static inline operator <T> T! getValue(androidx.compose.runtime.State<T>, Object? thisObj, kotlin.reflect.KProperty<?> property);
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> mutableStateListOf();
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> mutableStateListOf(T?... elements);
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> mutableStateMapOf();
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> mutableStateMapOf(kotlin.Pair<? extends K,? extends V>... pairs);
    method public static <T> androidx.compose.runtime.MutableState<T> mutableStateOf(T? value, optional androidx.compose.runtime.SnapshotMutationPolicy<T> policy);
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> neverEqualPolicy();
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> referentialEqualityPolicy();
    method public static inline operator <T> void setValue(androidx.compose.runtime.MutableState<T>, Object? thisObj, kotlin.reflect.KProperty<?> property, T? value);
    method @Deprecated @androidx.compose.runtime.Composable public static inline <T> androidx.compose.runtime.MutableState<T> state(optional androidx.compose.runtime.SnapshotMutationPolicy<T> policy, kotlin.jvm.functions.Function0<? extends T> init);
    method @Deprecated @androidx.compose.runtime.Composable public static inline <T, V1> androidx.compose.runtime.MutableState<T> stateFor(V1? v1, kotlin.jvm.functions.Function0<? extends T> init);
    method @androidx.compose.runtime.Composable public static inline <T> androidx.compose.runtime.MutableState<T> stateFor(Object![]? inputs, kotlin.jvm.functions.Function0<? extends T> init);
    method @androidx.compose.runtime.Composable public static inline <T, reified V1, reified V2> androidx.compose.runtime.MutableState<T>! stateFor(V1? v1, V2? v2, kotlin.jvm.functions.Function0<? extends T> init);
    method public static <T> androidx.compose.runtime.SnapshotMutationPolicy<T> structuralEqualityPolicy();
    method public static <T> androidx.compose.runtime.snapshots.SnapshotStateList<T> toMutableStateList(java.util.Collection<? extends T>);
    method public static <K, V> androidx.compose.runtime.snapshots.SnapshotStateMap<K,V> toMutableStateMap(Iterable<? extends kotlin.Pair<? extends K,? extends V>>);
  }

  @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface NoLiveLiterals {
  }

  public final class ObserverMap<K, V> {
    ctor public ObserverMap();
    method public void add(K key, V value);
    method public void clear();
    method public void clearValues(kotlin.jvm.functions.Function1<? super V,java.lang.Boolean> predicate);
    method public boolean contains(K key, V value);
    method public operator java.util.List<V> get(Iterable<? extends K> keys);
    method public java.util.List<V> getValueOf(K key);
    method public void remove(K key);
    method public void remove(K key, V value);
    method public void removeValue(V value);
  }

  @kotlin.PublishedApi internal final class PreCommitScopeImpl implements androidx.compose.runtime.CommitScope androidx.compose.runtime.CompositionLifecycleObserver {
    ctor public PreCommitScopeImpl(internal kotlin.jvm.functions.Function1<? super androidx.compose.runtime.CommitScope,kotlin.Unit> onCommit);
    method public void onDispose(kotlin.jvm.functions.Function0<kotlin.Unit> callback);
  }

  public final class ProduceStateKt {
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T? initialValue, @kotlin.BuilderInference kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> producer);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T? initialValue, Object? source, @kotlin.BuilderInference kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> producer);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T? initialValue, Object? source1, Object? source2, @kotlin.BuilderInference kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> producer);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T? initialValue, Object? source1, Object? source2, Object? source3, @kotlin.BuilderInference kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> producer);
    method @androidx.compose.runtime.Composable public static <T> androidx.compose.runtime.State<T> produceState(T? initialValue, Object![]? sources, @kotlin.BuilderInference kotlin.jvm.functions.Function2<? super androidx.compose.runtime.ProduceStateScope<T>,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> producer);
  }

  public interface ProduceStateScope<T> extends androidx.compose.runtime.MutableState<T> kotlinx.coroutines.CoroutineScope {
    method public suspend Object? awaitDispose(kotlin.jvm.functions.Function0<kotlin.Unit> onDispose, kotlin.coroutines.Continuation<?> p);
  }

  @androidx.compose.runtime.Stable public abstract class ProvidableAmbient<T> extends androidx.compose.runtime.Ambient<T> {
    method public final infix androidx.compose.runtime.ProvidedValue<T> provides(T? value);
  }

  public final class ProvidedValue<T> {
    method public androidx.compose.runtime.Ambient<T> getAmbient();
    method public T! getValue();
    property public final androidx.compose.runtime.Ambient<T> ambient;
    property public final T! value;
  }

  public final class Recomposer extends androidx.compose.runtime.CompositionReference {
    ctor public Recomposer(kotlin.coroutines.CoroutineContext effectCoroutineContext, androidx.compose.runtime.EmbeddingContext embeddingContext);
    method public suspend Object? awaitIdle(kotlin.coroutines.Continuation<? super kotlin.Unit> p);
    method public androidx.compose.runtime.EmbeddingContext getEmbeddingContext();
    method public boolean hasInvalidations();
    method public suspend Object? join(kotlin.coroutines.Continuation<? super kotlin.Unit> p);
    method public suspend Object? recomposeAndApplyChanges(long frameCount, kotlin.coroutines.Continuation<? super kotlin.Unit> p);
    method public suspend Object? runRecomposeAndApplyChanges(kotlin.coroutines.Continuation<?> p);
    method public void shutDown();
    property public final androidx.compose.runtime.EmbeddingContext embeddingContext;
    field public static final androidx.compose.runtime.Recomposer.Companion Companion;
  }

  public static final class Recomposer.Companion {
    method @org.jetbrains.annotations.TestOnly public androidx.compose.runtime.Recomposer current();
  }

  public final class RecomposerKt {
    method public static suspend <R> Object? withRunningRecomposer(kotlin.jvm.functions.Function3<? super kotlinx.coroutines.CoroutineScope,? super androidx.compose.runtime.Recomposer,? super kotlin.coroutines.Continuation<? super R>,?> block, kotlin.coroutines.Continuation<? super R> p);
  }

  public final class RememberKt {
    method @androidx.compose.runtime.Composable public static inline <T> T! remember(kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <T, V1> T! remember(V1? v1, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <T, V1, V2> T! remember(V1? v1, V2? v2, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <T, V1, V2, V3> T! remember(V1? v1, V2? v2, V3? v3, kotlin.jvm.functions.Function0<? extends T> calculation);
    method @androidx.compose.runtime.Composable public static inline <V> V! remember(Object![]? inputs, kotlin.jvm.functions.Function0<? extends V> calculation);
    method @androidx.compose.runtime.Composable public static inline <T> androidx.compose.runtime.State<T> rememberUpdatedState(T? newValue);
  }

  @androidx.compose.runtime.ComposeCompilerApi public interface ScopeUpdateScope {
    method public void updateScope(kotlin.jvm.functions.Function2<? super androidx.compose.runtime.Composer<?>,? super java.lang.Integer,kotlin.Unit> block);
  }

  public final class SideEffectKt {
    method @Deprecated @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(restartable=false) public static void DisposableEffect(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectDisposable> effect);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(restartable=false) public static void DisposableEffect(Object? subject, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectDisposable> effect);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(restartable=false) public static void DisposableEffect(Object? subject1, Object? subject2, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectDisposable> effect);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(restartable=false) public static void DisposableEffect(Object? subject1, Object? subject2, Object? subject3, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectDisposable> effect);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(restartable=false) public static void DisposableEffect(Object![]? subjects, kotlin.jvm.functions.Function1<? super androidx.compose.runtime.DisposableEffectScope,? extends androidx.compose.runtime.DisposableEffectDisposable> effect);
    method @androidx.compose.runtime.Composable @androidx.compose.runtime.ComposableContract(restartable=false) public static void SideEffect(kotlin.jvm.functions.Function0<kotlin.Unit> effect);
  }

  public final class SkippableUpdater<T> {
    ctor public SkippableUpdater(androidx.compose.runtime.Composer<?> composer, T? node);
    method public androidx.compose.runtime.Composer<?> getComposer();
    method public T! getNode();
    method public inline void update(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.Updater<T>,kotlin.Unit> block);
    property public final androidx.compose.runtime.Composer<?> composer;
    property public final T! node;
  }

  @androidx.compose.runtime.InternalComposeApi public final class SlotReader {
    ctor public SlotReader(internal androidx.compose.runtime.SlotTable table);
    method public androidx.compose.runtime.Anchor anchor(optional int index);
    method public void beginEmpty();
    method public void close();
    method public void endEmpty();
    method public void endGroup();
    method public java.util.List<androidx.compose.runtime.KeyInfo> extractKeys();
    method public Object? get(int index);
    method public int getCurrentEnd();
    method public int getCurrentGroup();
    method public Object! getGroupAux();
    method public int getGroupEnd();
    method public int getGroupKey();
    method public Object! getGroupNode();
    method public Object! getGroupObjectKey();
    method public int getGroupSize();
    method public int getGroupSlotCount();
    method public int getGroupSlotIndex();
    method public boolean getInEmpty();
    method public int getNodeCount();
    method public int getParent();
    method public int getParentNodes();
    method public int getSize();
    method public int getSlot();
    method public Object? groupAux(int index);
    method public int groupEnd(int index);
    method public Object? groupGet(int index);
    method public int groupKey(int index);
    method public int groupKey(androidx.compose.runtime.Anchor anchor);
    method public Object? groupObjectKey(int index);
    method public int groupSize(int index);
    method public boolean hasObjectKey(int index);
    method public boolean isGroupEnd();
    method public boolean isNode();
    method public boolean isNode(int index);
    method public Object? next();
    method public Object? node(int index);
    method public int nodeCount(int index);
    method public int parent(int index);
    method public int parentOf(int index);
    method public void reposition(int index);
    method public void restoreParent(int index);
    method public int skipGroup();
    method public void skipToGroupEnd();
    method public void startGroup();
    method public void startNode();
    property public final int currentEnd;
    property public final int currentGroup;
    property public final Object! groupAux;
    property public final int groupEnd;
    property public final int groupKey;
    property public final Object! groupNode;
    property public final Object! groupObjectKey;
    property public final int groupSize;
    property public final int groupSlotCount;
    property public final int groupSlotIndex;
    property public final boolean inEmpty;
    property public final boolean isGroupEnd;
    property public final boolean isNode;
    property public final int nodeCount;
    property public final int parent;
    property public final int parentNodes;
    property public final int size;
    property public final int slot;
  }

  @androidx.compose.runtime.InternalComposeApi public final class SlotTable {
    ctor public SlotTable();
    method public int anchorIndex(androidx.compose.runtime.Anchor anchor);
    method public String asString();
    method public int[] getGroups();
    method public int getGroupsSize();
    method public Object![] getSlots();
    method public int getSlotsSize();
    method public boolean isEmpty();
    method public androidx.compose.runtime.SlotReader openReader();
    method public androidx.compose.runtime.SlotWriter openWriter();
    method public boolean ownsAnchor(androidx.compose.runtime.Anchor anchor);
    method public inline <T> T! read(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.SlotReader,? extends T> block);
    method public void verifyWellFormed();
    method public inline <T> T! write(kotlin.jvm.functions.Function1<? super androidx.compose.runtime.SlotWriter,? extends T> block);
    property public final int[] groups;
    property public final int groupsSize;
    property public final boolean isEmpty;
    property public final Object![] slots;
    property public final int slotsSize;
  }

  public final class SlotTableKt {
    method public static java.util.List<java.lang.Integer> slice(int[], Iterable<java.lang.Integer> indices);
    field @kotlin.PublishedApi internal static final Object EMPTY;
  }

  @androidx.compose.runtime.InternalComposeApi public final class SlotWriter {
    method public void advanceBy(int amount);
    method public androidx.compose.runtime.Anchor anchor(optional int index);
    method public int anchorIndex(androidx.compose.runtime.Anchor anchor);
    method public void beginInsert();
    method public void close();
    method public int endGroup();
    method public void endInsert();
    method public void ensureStarted(int index);
    method public void ensureStarted(androidx.compose.runtime.Anchor anchor);
    method public boolean getClosed();
    method public int getCurrentGroup();
    method public int getParent();
    method public Object? groupAux(int index);
    method public int groupKey(int index);
    method public Object? groupObjectKey(int index);
    method public int groupSize(int index);
    method public java.util.Iterator<java.lang.Object> groupSlots();
    method public String groupsAsString();
    method public boolean isGroupEnd();
    method public boolean isNode();
    method public java.util.List<androidx.compose.runtime.Anchor> moveFrom(androidx.compose.runtime.SlotTable table, int index);
    method public void moveGroup(int offset);
    method public Object? node(int index);
    method public int parent(int index);
    method public int parent(androidx.compose.runtime.Anchor anchor);
    method public boolean removeGroup();
    method public void seek(androidx.compose.runtime.Anchor anchor);
    method public void set(Object? value);
    method public Object? set(int index, Object? value);
    method public Object? skip();
    method public int skipGroup();
    method public void skipToGroupEnd();
    method public void startData(int key, Object? objectKey, Object? aux);
    method public void startData(int key, Object? aux);
    method public void startGroup();
    method public void startGroup(int key);
    method public void startGroup(int key, Object? dataKey);
    method public void startNode(Object? key);
    method public void startNode(Object? key, Object? node);
    method public Object? update(Object? value);
    method public void updateAux(Object? value);
    method public void updateNode(Object? value);
    method public void updateParentNode(Object? value);
    property public final boolean closed;
    property public final int currentGroup;
    property public final boolean isGroupEnd;
    property public final boolean isNode;
    property public final int parent;
  }

  public interface SnapshotMutationPolicy<T> {
    method public boolean equivalent(T? a, T? b);
    method @androidx.compose.runtime.ExperimentalComposeApi public default T? merge(T? previous, T? current, T? applied);
  }

  @androidx.compose.runtime.StableMarker @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface Stable {
  }

  @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface StableMarker {
  }

  @androidx.compose.runtime.Stable public interface State<T> {
    method public T! getValue();
    property public abstract T! value;
  }

  public final class SuspendingEffectsKt {
    method @androidx.compose.runtime.Composable public static void LaunchedTask(kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void LaunchedTask(Object? key, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void LaunchedTask(Object? key1, Object? key2, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void LaunchedTask(Object? key1, Object? key2, Object? key3, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @androidx.compose.runtime.Composable public static void LaunchedTask(Object![]? keys, kotlin.jvm.functions.Function2<? super kotlinx.coroutines.CoroutineScope,? super kotlin.coroutines.Continuation<? super kotlin.Unit>,?> block);
    method @kotlin.PublishedApi internal static kotlinx.coroutines.CoroutineScope createCompositionCoroutineScope(kotlin.coroutines.CoroutineContext coroutineContext, androidx.compose.runtime.Composer<?> composer);
    method @androidx.compose.runtime.Composable public static inline kotlinx.coroutines.CoroutineScope rememberCoroutineScope(optional kotlin.jvm.functions.Function0<? extends kotlin.coroutines.CoroutineContext> getContext);
  }

  public final class TraceKt {
  }

  @androidx.compose.runtime.ExperimentalComposeApi @kotlin.annotation.MustBeDocumented @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface UnionType {
    method public abstract Class<?>[] types();
    property public abstract Class<?>![] types;
  }

  public final class Updater<T> {
    ctor public Updater(androidx.compose.runtime.Composer<?> composer, T? node);
    method public androidx.compose.runtime.Composer<?> getComposer();
    method public T! getNode();
    method public inline void reconcile(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void set(int value, kotlin.jvm.functions.Function2<? super T,? super java.lang.Integer,kotlin.Unit> block);
    method public inline <reified V> void set(V? value, kotlin.jvm.functions.Function2<? super T,? super V,? extends kotlin.Unit> block);
    method public inline void update(int value, kotlin.jvm.functions.Function2<? super T,? super java.lang.Integer,kotlin.Unit> block);
    method public inline <reified V> void update(V? value, kotlin.jvm.functions.Function2<? super T,? super V,? extends kotlin.Unit> block);
    property public final androidx.compose.runtime.Composer<?> composer;
    property public final T! node;
  }

}

package androidx.compose.runtime.collection {

  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level, message="This is an experimental API for fast access collections and is likely to change " + "before becoming stable.") @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget, kotlin.annotation.AnnotationTarget}) public @interface ExperimentalCollectionApi {
  }

  @androidx.compose.runtime.collection.ExperimentalCollectionApi public final class MutableVector<T> implements java.util.RandomAccess {
    ctor @kotlin.PublishedApi internal MutableVector(@kotlin.PublishedApi internal T![] content, int size);
    method public boolean add(T? element);
    method public void add(int index, T? element);
    method public boolean addAll(int index, java.util.List<? extends T> elements);
    method public boolean addAll(int index, androidx.compose.runtime.collection.MutableVector<T> elements);
    method public inline boolean addAll(java.util.List<? extends T> elements);
    method public inline boolean addAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean addAll(T![] elements);
    method public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public inline boolean any(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public java.util.List<T> asMutableList();
    method public void clear();
    method public operator boolean contains(T? element);
    method public boolean containsAll(java.util.List<? extends T> elements);
    method public boolean containsAll(java.util.Collection<? extends T> elements);
    method public boolean containsAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean contentEquals(androidx.compose.runtime.collection.MutableVector<T> other);
    method public void ensureCapacity(int capacity);
    method public T! first();
    method public inline T! first(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline T? firstOrNull();
    method public inline T? firstOrNull(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline <R> R! fold(R? initial, kotlin.jvm.functions.Function2<? super R,? super T,? extends R> operation);
    method public inline <R> R! foldIndexed(R? initial, kotlin.jvm.functions.Function3<? super java.lang.Integer,? super R,? super T,? extends R> operation);
    method public inline <R> R! foldRight(R? initial, kotlin.jvm.functions.Function2<? super T,? super R,? extends R> operation);
    method public inline <R> R! foldRightIndexed(R? initial, kotlin.jvm.functions.Function3<? super java.lang.Integer,? super T,? super R,? extends R> operation);
    method public inline void forEach(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void forEachIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,kotlin.Unit> block);
    method public inline void forEachReversed(kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method public inline void forEachReversedIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,kotlin.Unit> block);
    method public inline operator T! get(int index);
    method public inline kotlin.ranges.IntRange getIndices();
    method public inline int getLastIndex();
    method public int getSize();
    method public int indexOf(T? element);
    method public inline int indexOfFirst(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline int indexOfLast(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public boolean isEmpty();
    method public boolean isNotEmpty();
    method public T! last();
    method public inline T! last(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public int lastIndexOf(T? element);
    method public inline T? lastOrNull();
    method public inline T? lastOrNull(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public inline <reified R> R![]! map(kotlin.jvm.functions.Function1<? super T,? extends R> transform);
    method public inline <reified R> R![]! mapIndexed(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,? extends R> transform);
    method public inline <reified R> androidx.compose.runtime.collection.MutableVector<R>! mapIndexedNotNull(kotlin.jvm.functions.Function2<? super java.lang.Integer,? super T,? extends R> transform);
    method public inline <reified R> androidx.compose.runtime.collection.MutableVector<R>! mapNotNull(kotlin.jvm.functions.Function1<? super T,? extends R> transform);
    method public inline operator void minusAssign(T? element);
    method public inline operator void plusAssign(T? element);
    method public boolean remove(T? element);
    method public boolean removeAll(java.util.List<? extends T> elements);
    method public boolean removeAll(androidx.compose.runtime.collection.MutableVector<T> elements);
    method public boolean removeAll(java.util.Collection<? extends T> elements);
    method public T! removeAt(int index);
    method public void removeRange(int start, int end);
    method public boolean retainAll(java.util.Collection<? extends T> elements);
    method public inline boolean reversedAny(kotlin.jvm.functions.Function1<? super T,java.lang.Boolean> predicate);
    method public operator T! set(int index, T? element);
    method public void sortWith(java.util.Comparator<T> comparator);
    method public inline int sumBy(kotlin.jvm.functions.Function1<? super T,java.lang.Integer> selector);
    method @kotlin.PublishedApi internal Void throwNoSuchElementException();
    property public final inline kotlin.ranges.IntRange indices;
    property public final inline int lastIndex;
    property public final int size;
  }

  public final class MutableVectorKt {
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! MutableVector(optional int capacity);
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! MutableVector(int size, kotlin.jvm.functions.Function1<? super java.lang.Integer,? extends T> init);
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! mutableVectorOf();
    method @androidx.compose.runtime.collection.ExperimentalCollectionApi public static inline <reified T> androidx.compose.runtime.collection.MutableVector<T>! mutableVectorOf(T? elements);
  }

}

package androidx.compose.runtime.frames {

  @Deprecated public abstract class AbstractRecord implements androidx.compose.runtime.frames.Record {
    ctor @Deprecated public AbstractRecord();
    method @Deprecated public int getFrameId();
    method @Deprecated public androidx.compose.runtime.frames.Record? getNext();
    method @Deprecated public void setFrameId(int p);
    method @Deprecated public void setNext(androidx.compose.runtime.frames.Record? p);
    property public int frameId;
    property public androidx.compose.runtime.frames.Record? next;
  }

  public final class Frame {
    method public int getId();
    method public boolean getReadonly();
    method public boolean hasPendingChanges();
    property public final int id;
    property public final boolean readonly;
  }

  @Deprecated public final class FrameAborted extends java.lang.RuntimeException {
    ctor @Deprecated public FrameAborted(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public androidx.compose.runtime.frames.Frame getFrame();
    property public final androidx.compose.runtime.frames.Frame frame;
  }

  public final class FrameContainersKt {
    method @Deprecated public static <T> androidx.compose.runtime.frames.ModelList<T> modelListOf();
    method @Deprecated public static <T> androidx.compose.runtime.frames.ModelList<T> modelListOf(T? element);
    method @Deprecated public static <T> androidx.compose.runtime.frames.ModelList<T> modelListOf(T?... elements);
    method @Deprecated public static <K, V> androidx.compose.runtime.frames.ModelMap<K,V> modelMapOf();
    method @Deprecated public static <K, V> androidx.compose.runtime.frames.ModelMap<K,V> modelMapOf(kotlin.Pair<? extends K,? extends V>... pairs);
  }

  public final class FrameIdSetKt {
  }

  @Deprecated public interface Framed {
    method @Deprecated public androidx.compose.runtime.frames.Record getFirstFrameRecord();
    method @Deprecated public void prependFrameRecord(androidx.compose.runtime.frames.Record value);
    property public abstract androidx.compose.runtime.frames.Record firstFrameRecord;
  }

  public final class FramesKt {
    method @Deprecated public static void _created(androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static androidx.compose.runtime.frames.Record _readable(androidx.compose.runtime.frames.Record r, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static androidx.compose.runtime.frames.Record _writable(androidx.compose.runtime.frames.Record r, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static void abort();
    method @Deprecated public static void abort(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static void abortHandler();
    method @Deprecated public static void abortHandler(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static void commit();
    method @Deprecated public static void commit(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static void commitHandler();
    method @kotlin.PublishedApi internal static <T extends androidx.compose.runtime.frames.Record> T current(T r, androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static androidx.compose.runtime.frames.Frame currentFrame();
    method @Deprecated public static boolean getInFrame();
    method @Deprecated public static void observeAllReads(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit> readObserver, kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method @Deprecated public static void open(optional boolean readOnly);
    method @Deprecated public static void open(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function2<java.lang.Object,? super java.lang.Boolean,kotlin.Unit>? writeObserver);
    method @Deprecated public static <T extends androidx.compose.runtime.frames.Record> T readable(T, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static kotlin.jvm.functions.Function0<kotlin.Unit> registerCommitObserver(kotlin.jvm.functions.Function2<? super java.util.Set<?>,? super androidx.compose.runtime.frames.Frame,kotlin.Unit> observer);
    method @Deprecated public static void restore(androidx.compose.runtime.frames.Frame frame);
    method @Deprecated public static androidx.compose.runtime.frames.Frame suspend();
    method @Deprecated public static boolean wasModified(Object value);
    method @Deprecated public static inline <T extends androidx.compose.runtime.frames.Record> T withCurrent(T, kotlin.jvm.functions.Function1<? super T,kotlin.Unit> block);
    method @Deprecated public static <T extends androidx.compose.runtime.frames.Record> T writable(T, androidx.compose.runtime.frames.Framed framed);
    method @Deprecated public static <T extends androidx.compose.runtime.frames.Record> T writable(T, androidx.compose.runtime.frames.Framed framed, androidx.compose.runtime.frames.Frame frame);
  }

  @Deprecated public final class ModelList<T> implements androidx.compose.runtime.frames.Framed kotlin.jvm.internal.markers.KMutableList java.util.List<T> {
    ctor @Deprecated public ModelList();
    method @Deprecated public boolean add(T? element);
    method @Deprecated public void add(int index, T? element);
    method @Deprecated public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method @Deprecated public boolean addAll(java.util.Collection<? extends T> elements);
    method @Deprecated public void clear();
    method @Deprecated public boolean contains(Object? element);
    method @Deprecated public boolean containsAll(java.util.Collection<?> elements);
    method @Deprecated public T! get(int index);
    method @Deprecated public androidx.compose.runtime.frames.Record getFirstFrameRecord();
    method @Deprecated public int getSize();
    method @Deprecated public int indexOf(Object? element);
    method @Deprecated public boolean isEmpty();
    method @Deprecated public java.util.Iterator<T> iterator();
    method @Deprecated public int lastIndexOf(Object? element);
    method @Deprecated public java.util.ListIterator<T> listIterator();
    method @Deprecated public java.util.ListIterator<T> listIterator(int index);
    method @Deprecated public void prependFrameRecord(androidx.compose.runtime.frames.Record value);
    method @Deprecated public boolean remove(Object? element);
    method @Deprecated public boolean removeAll(java.util.Collection<?> elements);
    method @Deprecated public T! removeAt(int index);
    method @Deprecated public boolean retainAll(java.util.Collection<?> elements);
    method @Deprecated public T! set(int index, T? element);
    method @Deprecated public java.util.List<T> subList(int fromIndex, int toIndex);
    property public androidx.compose.runtime.frames.Record firstFrameRecord;
    property public int size;
  }

  @Deprecated public final class ModelMap<K, V> implements androidx.compose.runtime.frames.Framed kotlin.jvm.internal.markers.KMutableMap java.util.Map<K,V> {
    ctor @Deprecated public ModelMap();
    method @Deprecated public void clear();
    method @Deprecated public boolean containsKey(Object? key);
    method @Deprecated public boolean containsValue(Object? value);
    method @Deprecated public V? get(Object? key);
    method @Deprecated public java.util.Set<java.util.Map.Entry<K,V>> getEntries();
    method @Deprecated public androidx.compose.runtime.frames.Record getFirstFrameRecord();
    method @Deprecated public java.util.Set<K> getKeys();
    method @Deprecated public int getSize();
    method @Deprecated public java.util.Collection<V> getValues();
    method @Deprecated public boolean isEmpty();
    method @Deprecated public void prependFrameRecord(androidx.compose.runtime.frames.Record value);
    method @Deprecated public V? put(K? key, V? value);
    method @Deprecated public void putAll(java.util.Map<? extends K,? extends V> from);
    method @Deprecated public V? remove(Object? key);
    property public java.util.Set<java.util.Map.Entry<K,V>> entries;
    property public androidx.compose.runtime.frames.Record firstFrameRecord;
    property public java.util.Set<K> keys;
    property public int size;
    property public java.util.Collection<V> values;
  }

  @Deprecated public interface Record {
    method @Deprecated public void assign(androidx.compose.runtime.frames.Record value);
    method @Deprecated public androidx.compose.runtime.frames.Record create();
    method @Deprecated public int getFrameId();
    method @Deprecated public androidx.compose.runtime.frames.Record? getNext();
    method @Deprecated public void setFrameId(int p);
    method @Deprecated public void setNext(androidx.compose.runtime.frames.Record? p);
    property public abstract int frameId;
    property public abstract androidx.compose.runtime.frames.Record? next;
  }

}

package androidx.compose.runtime.internal {

  @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.Stable public final class ComposableLambda<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, R> implements kotlin.jvm.functions.Function10<P1,P2,P3,P4,P5,P6,P7,P8,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function11<P1,P2,P3,P4,P5,P6,P7,P8,P9,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function12<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function13<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function14<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function15<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function16<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function17<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function19<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function2<androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function20<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,P17,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function21<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,P17,P18,androidx.compose.runtime.Composer<?>,java.lang.Integer,java.lang.Integer,R> kotlin.jvm.functions.Function3<P1,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function4<P1,P2,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function5<P1,P2,P3,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function6<P1,P2,P3,P4,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function7<P1,P2,P3,P4,P5,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function8<P1,P2,P3,P4,P5,P6,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> kotlin.jvm.functions.Function9<P1,P2,P3,P4,P5,P6,P7,androidx.compose.runtime.Composer<?>,java.lang.Integer,R> {
    ctor public ComposableLambda(int key, boolean tracked, String? sourceInformation);
    method public int getKey();
    method public operator R! invoke(androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, androidx.compose.runtime.Composer<?> c, int changed);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, P16? p16, androidx.compose.runtime.Composer<?> c, int changed, int changed1);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, P16? p16, P17? p17, androidx.compose.runtime.Composer<?> c, int changed, int changed1);
    method public operator R! invoke(P1? p1, P2? p2, P3? p3, P4? p4, P5? p5, P6? p6, P7? p7, P8? p8, P9? p9, P10? p10, P11? p11, P12? p12, P13? p13, P14? p14, P15? p15, P16? p16, P17? p17, P18? p18, androidx.compose.runtime.Composer<?> c, int changed, int changed1);
    method public void update(Object block);
    property public final int key;
  }

  public final class ComposableLambdaKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda<java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object> composableLambda(androidx.compose.runtime.Composer<?> composer, int key, boolean tracked, String? sourceInformation, Object block);
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambda<java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object> composableLambdaInstance(int key, boolean tracked, Object block);
  }

  @androidx.compose.runtime.ComposeCompilerApi @androidx.compose.runtime.Stable public final class ComposableLambdaN<R> implements kotlin.jvm.functions.FunctionN<R> {
    ctor public ComposableLambdaN(int key, boolean tracked, String? sourceInformation, int arity);
    method public int getArity();
    method public int getKey();
    method public R! invoke(java.lang.Object?... args);
    method public void update(Object block, androidx.compose.runtime.Composer<?>? composer);
    property public int arity;
    property public final int key;
  }

  public final class ComposableLambdaNKt {
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN<?> composableLambdaN(androidx.compose.runtime.Composer<?> composer, int key, boolean tracked, String? sourceInformation, int arity, Object block);
    method @androidx.compose.runtime.ComposeCompilerApi public static androidx.compose.runtime.internal.ComposableLambdaN<?> composableLambdaNInstance(int key, boolean tracked, int arity, Object block);
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) public @interface LiveLiteralFileInfo {
    method public abstract String file();
    property public abstract String file;
  }

  @androidx.compose.runtime.ComposeCompilerApi @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention) public @interface LiveLiteralInfo {
    method public abstract String key();
    method public abstract int offset();
    property public abstract String key;
    property public abstract int offset;
  }

  public final class LiveLiteralKt {
    method public static boolean isLiveLiteralsEnabled();
    method @androidx.compose.runtime.InternalComposeApi public static <T> androidx.compose.runtime.State<T> liveLiteral(String key, T? value);
    method @androidx.compose.runtime.InternalComposeApi public static void updateLiveLiteralValue(String key, Object? value);
  }

}

package androidx.compose.runtime.snapshots {

  public final class ListUtilsKt {
  }

  @androidx.compose.runtime.ExperimentalComposeApi public class MutableSnapshot extends androidx.compose.runtime.snapshots.Snapshot {
    method public androidx.compose.runtime.snapshots.SnapshotApplyResult apply();
    method public void close$metalava_module();
    method public java.util.Set<androidx.compose.runtime.snapshots.StateObject>? getModified$metalava_module();
    method public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? getReadObserver$metalava_module();
    method public boolean getReadonly();
    method public androidx.compose.runtime.snapshots.Snapshot getRoot();
    method public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? getWriteObserver$metalava_module();
    method public boolean hasPendingChanges();
    method public void nestedActivated$metalava_module(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void nestedDeactivated$metalava_module(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void notifyObjectsInitialized$metalava_module();
    method public void recordModified$metalava_module(androidx.compose.runtime.snapshots.StateObject state);
    method public void setModified(java.util.Set<androidx.compose.runtime.snapshots.StateObject>? p);
    method public androidx.compose.runtime.snapshots.MutableSnapshot takeNestedMutableSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver);
    method public androidx.compose.runtime.snapshots.Snapshot takeNestedSnapshot(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    property public java.util.Set<androidx.compose.runtime.snapshots.StateObject>? modified;
    property public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver;
    property public boolean readonly;
    property public androidx.compose.runtime.snapshots.Snapshot root;
    property public kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public abstract sealed class Snapshot {
    method public void dispose();
    method public final inline <T> T! enter(kotlin.jvm.functions.Function0<? extends T> block);
    method public int getId();
    method public abstract boolean getReadonly();
    method public abstract androidx.compose.runtime.snapshots.Snapshot getRoot();
    method public abstract boolean hasPendingChanges();
    method @kotlin.PublishedApi internal androidx.compose.runtime.snapshots.Snapshot? makeCurrent();
    method @kotlin.PublishedApi internal void restoreCurrent(androidx.compose.runtime.snapshots.Snapshot? snapshot);
    method public abstract androidx.compose.runtime.snapshots.Snapshot takeNestedSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    property public int id;
    property public abstract boolean readonly;
    property public abstract androidx.compose.runtime.snapshots.Snapshot root;
    field public static final androidx.compose.runtime.snapshots.Snapshot.Companion Companion;
  }

  public static final class Snapshot.Companion {
    method public androidx.compose.runtime.snapshots.Snapshot! getCurrent();
    method public inline <T> T! global(kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ExperimentalComposeApi public void notifyObjectsInitialized();
    method public <T> T! observe(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver, kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.InternalComposeApi public int openSnapshotCount();
    method public kotlin.jvm.functions.Function0<kotlin.Unit> registerApplyObserver(kotlin.jvm.functions.Function2<? super java.util.Set<?>,? super androidx.compose.runtime.snapshots.Snapshot,kotlin.Unit> observer);
    method @androidx.compose.runtime.ExperimentalComposeApi public kotlin.jvm.functions.Function0<kotlin.Unit> registerGlobalWriteObserver(kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit> observer);
    method @kotlin.PublishedApi internal androidx.compose.runtime.snapshots.Snapshot? removeCurrent();
    method @kotlin.PublishedApi internal void restoreCurrent(androidx.compose.runtime.snapshots.Snapshot? previous);
    method @androidx.compose.runtime.ExperimentalComposeApi public void sendApplyNotifications();
    property public final androidx.compose.runtime.snapshots.Snapshot! current;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public final class SnapshotApplyConflictException extends java.lang.Exception {
    ctor public SnapshotApplyConflictException(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public androidx.compose.runtime.snapshots.Snapshot getSnapshot();
    property public final androidx.compose.runtime.snapshots.Snapshot snapshot;
  }

  public abstract sealed class SnapshotApplyResult {
    method public abstract void check();
    method public abstract boolean getSucceeded();
    property public abstract boolean succeeded;
  }

  public static final class SnapshotApplyResult.Failure extends androidx.compose.runtime.snapshots.SnapshotApplyResult {
    ctor public SnapshotApplyResult.Failure(androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public void check();
    method public androidx.compose.runtime.snapshots.Snapshot getSnapshot();
    method public boolean getSucceeded();
    property public final androidx.compose.runtime.snapshots.Snapshot snapshot;
    property public boolean succeeded;
  }

  public static final class SnapshotApplyResult.Success extends androidx.compose.runtime.snapshots.SnapshotApplyResult {
    method public void check();
    method public boolean getSucceeded();
    property public boolean succeeded;
    field public static final androidx.compose.runtime.snapshots.SnapshotApplyResult.Success INSTANCE;
  }

  public final class SnapshotFlowKt {
    method @androidx.compose.runtime.ExperimentalComposeApi public static <T> kotlinx.coroutines.flow.Flow<T> snapshotFlow(kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ExperimentalComposeApi public static inline <R> R! withMutableSnapshot(kotlin.jvm.functions.Function0<? extends R> block);
  }

  public final class SnapshotIdSetKt {
  }

  public final class SnapshotKt {
    method @kotlin.PublishedApi internal static <T extends androidx.compose.runtime.snapshots.StateRecord> T current(T r, androidx.compose.runtime.snapshots.Snapshot snapshot);
    method @kotlin.PublishedApi internal static void notifyWrite(androidx.compose.runtime.snapshots.Snapshot snapshot, androidx.compose.runtime.snapshots.StateObject state);
    method public static <T extends androidx.compose.runtime.snapshots.StateRecord> T readable(T, androidx.compose.runtime.snapshots.StateObject state);
    method public static <T extends androidx.compose.runtime.snapshots.StateRecord> T readable(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot);
    method @kotlin.PublishedApi internal static inline <T> T! sync(kotlin.jvm.functions.Function0<? extends T> block);
    method @androidx.compose.runtime.ExperimentalComposeApi public static androidx.compose.runtime.snapshots.MutableSnapshot takeMutableSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver, optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? writeObserver);
    method public static androidx.compose.runtime.snapshots.Snapshot takeSnapshot(optional kotlin.jvm.functions.Function1<java.lang.Object,kotlin.Unit>? readObserver);
    method @androidx.compose.runtime.ExperimentalComposeApi public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R! withCurrent(T, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R! writable(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method public static inline <T extends androidx.compose.runtime.snapshots.StateRecord, R> R! writable(T, androidx.compose.runtime.snapshots.StateObject state, kotlin.jvm.functions.Function1<? super T,? extends R> block);
    method @kotlin.PublishedApi internal static <T extends androidx.compose.runtime.snapshots.StateRecord> T writableRecord(T, androidx.compose.runtime.snapshots.StateObject state, androidx.compose.runtime.snapshots.Snapshot snapshot);
    field @kotlin.PublishedApi internal static final Object lock;
    field @kotlin.PublishedApi internal static final androidx.compose.runtime.snapshots.Snapshot snapshotInitializer;
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateList<T> implements kotlin.jvm.internal.markers.KMutableList java.util.List<T> androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateList();
    method public boolean add(T? element);
    method public void add(int index, T? element);
    method public boolean addAll(int index, java.util.Collection<? extends T> elements);
    method public boolean addAll(java.util.Collection<? extends T> elements);
    method public void clear();
    method public boolean contains(Object? element);
    method public boolean containsAll(java.util.Collection<?> elements);
    method public T! get(int index);
    method public androidx.compose.runtime.snapshots.SnapshotStateList.StateListStateRecord<T> getFirstStateRecord();
    method public int getSize();
    method public int indexOf(Object? element);
    method public boolean isEmpty();
    method public java.util.Iterator<T> iterator();
    method public int lastIndexOf(Object? element);
    method public java.util.ListIterator<T> listIterator();
    method public java.util.ListIterator<T> listIterator(int index);
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method public boolean remove(Object? element);
    method public boolean removeAll(java.util.Collection<?> elements);
    method public T! removeAt(int index);
    method public void removeRange(int fromIndex, int toIndex);
    method public boolean retainAll(java.util.Collection<?> elements);
    method public T! set(int index, T? element);
    method public java.util.List<T> subList(int fromIndex, int toIndex);
    property public androidx.compose.runtime.snapshots.SnapshotStateList.StateListStateRecord<T> firstStateRecord;
    property public int size;
  }

  public static final class SnapshotStateList.StateListStateRecord<T> extends androidx.compose.runtime.snapshots.StateRecord {
    method public void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public androidx.compose.runtime.snapshots.StateRecord create();
  }

  public final class SnapshotStateListKt {
  }

  @androidx.compose.runtime.Stable public final class SnapshotStateMap<K, V> implements kotlin.jvm.internal.markers.KMutableMap java.util.Map<K,V> androidx.compose.runtime.snapshots.StateObject {
    ctor public SnapshotStateMap();
    method public void clear();
    method public boolean containsKey(Object? key);
    method public boolean containsValue(Object? value);
    method public V? get(Object? key);
    method public java.util.Set<java.util.Map.Entry<K,V>> getEntries();
    method public androidx.compose.runtime.snapshots.SnapshotStateMap.StateMapStateRecord<K,V> getFirstStateRecord();
    method public java.util.Set<K> getKeys();
    method public int getSize();
    method public java.util.Collection<V> getValues();
    method public boolean isEmpty();
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    method public V? put(K? key, V? value);
    method public void putAll(java.util.Map<? extends K,? extends V> from);
    method public V? remove(Object? key);
    property public java.util.Set<java.util.Map.Entry<K,V>> entries;
    property public androidx.compose.runtime.snapshots.SnapshotStateMap.StateMapStateRecord<K,V> firstStateRecord;
    property public java.util.Set<K> keys;
    property public int size;
    property public java.util.Collection<V> values;
  }

  public static final class SnapshotStateMap.StateMapStateRecord<K, V> extends androidx.compose.runtime.snapshots.StateRecord {
    method public void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public androidx.compose.runtime.snapshots.StateRecord create();
  }

  public final class SnapshotStateMapKt {
  }

  @androidx.compose.runtime.ExperimentalComposeApi public final class SnapshotStateObserver {
    ctor public SnapshotStateObserver(kotlin.jvm.functions.Function1<? super kotlin.jvm.functions.Function0<kotlin.Unit>,kotlin.Unit> onChangedExecutor);
    method public void clear(Object target);
    method public void clear();
    method public void dispose();
    method public void enableStateUpdatesObserving(boolean enabled);
    method @org.jetbrains.annotations.TestOnly public void notifyChanges(java.util.Set<?> changes, androidx.compose.runtime.snapshots.Snapshot snapshot);
    method public <T> void observeReads(T target, kotlin.jvm.functions.Function1<? super T,kotlin.Unit> onChanged, kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method public void pauseObservingReads(kotlin.jvm.functions.Function0<kotlin.Unit> block);
    method public void removeObservationsFor(kotlin.jvm.functions.Function1<java.lang.Object,java.lang.Boolean> predicate);
  }

  @androidx.compose.runtime.ExperimentalComposeApi public interface StateObject {
    method public androidx.compose.runtime.snapshots.StateRecord getFirstStateRecord();
    method public default androidx.compose.runtime.snapshots.StateRecord? mergeRecords(androidx.compose.runtime.snapshots.StateRecord previous, androidx.compose.runtime.snapshots.StateRecord current, androidx.compose.runtime.snapshots.StateRecord applied);
    method public void prependStateRecord(androidx.compose.runtime.snapshots.StateRecord value);
    property public abstract androidx.compose.runtime.snapshots.StateRecord firstStateRecord;
  }

  @androidx.compose.runtime.ExperimentalComposeApi public abstract class StateRecord {
    ctor public StateRecord();
    method public abstract void assign(androidx.compose.runtime.snapshots.StateRecord value);
    method public abstract androidx.compose.runtime.snapshots.StateRecord create();
  }

}

package androidx.compose.runtime.tooling {

  public final class InspectionTablesKt {
    method public static androidx.compose.runtime.ProvidableAmbient<java.util.Set<androidx.compose.runtime.SlotTable>> getInspectionTables();
  }

}

