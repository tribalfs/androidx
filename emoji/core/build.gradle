import static android.support.dependencies.DependenciesKt.*
import android.support.LibraryGroups
import android.support.LibraryVersions
import java.util.zip.ZipException
import java.util.zip.ZipFile

plugins {
    id("SupportAndroidLibraryPlugin")
}

ext {
    fontDir = project(':noto-emoji-compat').projectDir
}

configurations {
    repackage
}

dependencies {
    repackage project(path: ':noto-emoji-compat', configuration: "parser")
    // Wrap the noto-emoji-compat dependency in a FileCollection so that the Android Gradle plugin
    // treats this as local jar and package it inside the aar.
    api files(configurations.repackage)

    api(project(":support-compat"))

    androidTestImplementation(TEST_RUNNER)
    androidTestImplementation(ESPRESSO_CORE)
    androidTestImplementation(MOCKITO_CORE, libs.exclude_bytebuddy) // DexMaker has it"s own MockMaker
    androidTestImplementation(DEXMAKER_MOCKITO, libs.exclude_bytebuddy) // DexMaker has it"s own MockMaker
    androidTestImplementation project(':support-testutils')
}

android {
    sourceSets {
        main {
            // We use a non-standard manifest path.
            manifest.srcFile 'AndroidManifest.xml'
            res.srcDirs += 'src/main/res-public'
            resources {
                srcDirs = [fontDir.getAbsolutePath()]
                includes = ["LICENSE_UNICODE", "LICENSE_OFL"]
            }
        }

        androidTest {
            // We use a non-standard test directory structure.
            root 'tests'
            java.srcDir 'tests/src'
            res.srcDir 'tests/res'
            manifest.srcFile 'tests/AndroidManifest.xml'
            assets {
                srcDirs = [new File(fontDir, "font").getAbsolutePath(),
                           new File(fontDir, "supported-emojis").getAbsolutePath()]
            }
        }
    }
}

supportLibrary {
    name = "Android Emoji Compat"
    publish = true
    mavenVersion = LibraryVersions.SUPPORT_LIBRARY
    mavenGroup = LibraryGroups.SUPPORT
    inceptionYear = "2017"
    description = "Core library to enable emoji compatibility in Kitkat and newer devices to avoid the empty emoji characters."

    license {
        name = "SIL Open Font License, Version 1.1"
        url = "http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web"
    }

    license {
        name = "Unicode, Inc. License"
        url = "http://www.unicode.org/copyright.html#License"
    }
}

import org.gradle.api.Task
import org.gradle.api.tasks.TaskAction

class ValidateJarInput extends DefaultTask {
    Task syncTask

    @TaskAction
    void validate() {
        for (File f : syncTask.inputs.files.files) {
            if (f.name.endsWith(".jar")) {
                ZipFile zip = null
                for (def i : 0..3) {
                    try {
                        zip = new ZipFile(f)
                        if (i > 0) {
                            // If we get here, we know this is some timing issues.  The jar file is
                            // properly created, but only if we wait.
                            logger.error("Succeeded in opening jar file '$f' after $i retries.  Failing build.")
                            throw new RuntimeException("Failed opening zip file earlier.")
                        }
                        break
                    } catch (ZipException e) {
                        logger.error("Error opening jar file '$f' (attempt: $i): $e.message")
                        sleep(1000)
                    } finally {
                        if (zip != null) {
                            zip.close()
                        }
                    }
                    if (i == 3) {
                        // We failed after 3 retries, this means the generated file is not a proper
                        // jar file.
                        throw new RuntimeException("Failed opening zip file after 3 retries.")
                    }
                }
            }
        }
    }
}

afterEvaluate {
    def syncJniTask = tasks.getByName("transformNativeLibsWithSyncJniLibsForRelease")
    println "found $syncJniTask.name"
    def validateTask = tasks.create("validateJarInputsForRelease", ValidateJarInput.class) { t ->
        t.syncTask = syncJniTask
    }
    validateTask.dependsOn(syncJniTask.getDependsOn().collect())
    syncJniTask.dependsOn(validateTask)
}
