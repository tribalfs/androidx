/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.support.navigation.app.nav;

import static android.support.annotation.RestrictTo.Scope.LIBRARY_GROUP;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.annotation.CallSuper;
import android.support.annotation.DrawableRes;
import android.support.annotation.IdRes;
import android.support.annotation.IntDef;
import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import android.support.v4.util.SparseArrayCompat;
import android.util.AttributeSet;

import com.android.support.navigation.R;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * NavDestination represents one node within an overall navigation graph.
 *
 * <p>Each destination is associated with a {@link Navigator} which knows how to navigate to this
 * particular destination.</p>
 *
 * <p>Destinations declare a set of {@link #putAction(int, int) actions} that they
 * support. These actions form a navigation API for the destination; the same actions declared
 * on different destinations that fill similar roles allow application code to navigate based
 * on semantic intent.</p>
 *
 * <p>Each destination has a set of {@link #getDefaultArguments() default arguments} that will
 * be applied when {@link NavController#navigate(int, Bundle) navigating} to that destination.
 * These arguments can be overridden at the time of navigation.</p>
 */
public class NavDestination {
    /**
     * @hide
     */
    @RestrictTo(LIBRARY_GROUP)
    @IntDef(value = {NAV_TYPE_NONE, NAV_TYPE_SECONDARY, NAV_TYPE_PRIMARY})
    @Retention(RetentionPolicy.SOURCE)
    public @interface NavTypes {}

    /**
     * Indicates this destination should not be shown in navigation menus generated from the
     * containing {@link NavGraph}.
     *
     * @see #setNavType
     */
    public static final int NAV_TYPE_NONE = 0;

    /**
     * Indicates this destination should be shown in secondary navigation menus generated from the
     * containing {@link NavGraph}.
     *
     * @see #setNavType
     */
    public static final int NAV_TYPE_SECONDARY = 1;

    /**
     * Indicates this destination should be shown in primary navigation menus generated from the
     * containing {@link NavGraph}.
     *
     * @see #setNavType
     */
    public static final int NAV_TYPE_PRIMARY = 2;

    private final Navigator mNavigator;
    private NavGraph mParent;
    private int mId;
    @DrawableRes
    private int mIconResId;
    private Drawable mIconDrawable;
    private CharSequence mLabel;
    @NavTypes
    private int mNavType;
    private Bundle mDefaultArgs;
    private SparseArrayCompat<NavAction> mActions;

    /**
     * NavDestinations should be created via {@link Navigator#createDestination}.
     */
    public NavDestination(@NonNull Navigator<? extends NavDestination> navigator) {
        mNavigator = navigator;
    }

    /**
     * Called when inflating a destination from a resource.
     *
     * @param context local context performing inflation
     * @param attrs attrs to parse during inflation
     */
    @CallSuper
    public void onInflate(Context context, AttributeSet attrs) {
        final TypedArray a = context.getResources().obtainAttributes(attrs,
                R.styleable.Navigator);
        setId(a.getResourceId(R.styleable.Navigator_android_id, 0));
        setIcon(a.getDrawable(R.styleable.Navigator_android_icon));
        setLabel(a.getText(R.styleable.Navigator_android_label));
        @NavTypes
        int navType = a.getInt(R.styleable.Navigator_navType, NAV_TYPE_NONE);
        setNavType(navType);
        a.recycle();
    }

    void setParent(NavGraph parent) {
        mParent = parent;
    }

    /**
     * Gets the {@link NavGraph} that contains this destination. This will be set when a
     * destination is added to a NavGraph via {@link NavGraph#addDestination}.
     * @return
     */
    public NavGraph getParent() {
        return mParent;
    }

    /**
     * Returns the destination's unique ID. This should be an ID resource generated by
     * the Android resource system.
     *
     * @return this destination's ID
     */
    @IdRes
    public int getId() {
        return mId;
    }

    /**
     * Sets the destination's unique ID. This should be an ID resource generated by
     * the Android resource system.
     *
     * @param id this destination's new ID
     */
    public void setId(@IdRes int id) {
        mId = id;
    }

    /**
     * Sets the icon associated with this destination.
     *
     * @param iconResId The resource id of the Drawable to use as the icon.
     */
    public void setIcon(@DrawableRes int iconResId) {
        mIconDrawable = null;
        mIconResId = iconResId;
    }

    /**
     * Gets the resource id of the icon of this destination.
     *
     * <p>This is mutually exclusive with a drawable set via {@link #setIcon(Drawable)}.</p>
     */
    @DrawableRes
    public int getIconResourceId() {
        return mIconResId;
    }

    /**
     * Sets the icon associated with this destination.
     *
     * @param icon The Drawable to use as the icon.
     */
    public void setIcon(Drawable icon) {
        mIconResId = 0;
        mIconDrawable = icon;
    }


    /**
     * Gets the Drawable representation of the icon of this destination.
     *
     * <p>This is mutually exclusive with a drawable set via {@link #setIcon(int)}.</p>
     */
    public Drawable getIconDrawable() {
        return mIconDrawable;
    }

    /**
     * Sets the descriptive label of this destination.
     *
     * @param label A descriptive label of this destination.
     */
    public void setLabel(CharSequence label) {
        mLabel = label;
    }

    /**
     * Gets the descriptive label of this destination.
     */
    public CharSequence getLabel() {
        return mLabel;
    }

    /**
     * Sets the navigation type for this destination. This can be used to determine the relative
     * priority of destinations.
     *
     * @param navType The navigation type of this destination. Must be one of
     *                {@link #NAV_TYPE_PRIMARY}, {@link #NAV_TYPE_SECONDARY}, or
     *                {@link #NAV_TYPE_NONE}.
     * @see #NAV_TYPE_PRIMARY
     * @see #NAV_TYPE_SECONDARY
     * @see #NAV_TYPE_NONE
     */
    public void setNavType(@NavTypes int navType) {
        if (navType != NAV_TYPE_PRIMARY && navType != NAV_TYPE_SECONDARY
                && navType != NAV_TYPE_NONE) {
            throw new IllegalArgumentException("Invalid navType " + navType);
        }
        mNavType = navType;
    }

    /**
     * Gets the navigation type of this destination.
     * @return The navigation type of this destination. Will be one of
     * {@link #NAV_TYPE_PRIMARY}, {@link #NAV_TYPE_SECONDARY}, or {@link #NAV_TYPE_NONE}.
     *
     * @see #NAV_TYPE_PRIMARY
     * @see #NAV_TYPE_SECONDARY
     * @see #NAV_TYPE_NONE
     */
    @NavTypes
    public int getNavType() {
        return mNavType;
    }

    /**
     * Returns the destination's {@link Navigator}.
     *
     * @return this destination's navigator
     */
    public Navigator getNavigator() {
        return mNavigator;
    }

    /**
     * Returns the destination's default arguments bundle.
     *
     * @return the default arguments bundle
     */
    public @NonNull Bundle getDefaultArguments() {
        if (mDefaultArgs == null) {
            mDefaultArgs = new Bundle();
        }
        return mDefaultArgs;
    }

    /**
     * Sets the destination's default arguments bundle.
     *
     * @param args the new bundle to set
     */
    public void setDefaultArguments(Bundle args) {
        mDefaultArgs = args;
    }

    /**
     * Merges a bundle of arguments into the current default arguments for this destination.
     * New values with the same keys will replace old values with those keys.
     *
     * @param args arguments to add
     */
    public void addDefaultArguments(Bundle args) {
        getDefaultArguments().putAll(args);
    }

    /**
     * Returns the destination ID for a given action. This will recursively check the
     * {@link #getParent() parent} of this destination if the action destination is not found in
     * this destination.
     *
     * @param id action ID to fetch
     * @return destination ID mapped to the given action id, or 0 if none
     */
    public NavAction getAction(@IdRes int id) {
        NavAction destination = mActions == null ? null : mActions.get(id);
        // Search the parent for the given action if it is not found in this destination
        return destination != null
                ? destination
                : getParent() != null ? getParent().getAction(id) : null;
    }

    /**
     * Sets a destination ID for an action ID.
     *
     * @param actionId action ID to bind
     * @param destId destination ID for the given action
     */
    public void putAction(@IdRes int actionId, @IdRes int destId) {
        putAction(actionId, new NavAction(destId));
    }

    /**
     * Sets a destination ID for an action ID.
     *
     * @param actionId action ID to bind
     * @param action action to associate with this action ID
     */
    public void putAction(@IdRes int actionId, @NonNull NavAction action) {
        if (actionId == 0) {
            throw new IllegalArgumentException("Cannot have an action with actionId 0");
        }
        if (mActions == null) {
            mActions = new SparseArrayCompat<>();
        }
        mActions.put(actionId, action);
    }

    /**
     * Unsets the destination ID for an action ID.
     *
     * @param actionId action ID to remove
     */
    public void removeAction(@IdRes int actionId) {
        if (mActions == null) {
            return;
        }
        mActions.delete(actionId);
    }

    /**
     * Navigates to this destination.
     *
     * <p>Uses the {@link #getNavigator() configured navigator} to navigate to this destination.
     * Apps should not call this directly, instead use {@link NavController}'s navigation methods
     * to ensure consistent back stack tracking and behavior.</p>
     *
     * @param args arguments to the new destination
     * @param navOptions options for navigation
     * @return true if navigation created a back stack entry that should be tracked
     */
    public boolean navigate(Bundle args, NavOptions navOptions) {
        Bundle finalArgs = null;
        Bundle defaultArgs = getDefaultArguments();
        if (defaultArgs != null) {
            finalArgs = new Bundle();
            finalArgs.putAll(defaultArgs);
        }
        if (args != null) {
            if (finalArgs == null) {
                finalArgs = new Bundle();
            }
            finalArgs.putAll(args);
        }
        return mNavigator.navigate(this, finalArgs, navOptions);
    }
}
